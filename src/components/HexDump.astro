---
---

<div class="tool-container">
	<div class="tool-header">
		<h1>üìä Hex Dump Tool</h1>
		<p>Binary file analysis with hexdump display and visual representation</p>
	</div>
	
	<div class="glass-card tool-controls">
		<div class="file-input">
			<input type="file" id="file-input" accept="*/*" />
			<div class="file-input-label">
				<span>üìÅ Choose Binary File</span>
			</div>
		</div>
		<div class="file-info">
			<div class="file-detail">
				<span class="file-label">File:</span>
				<span id="file-name">No file selected</span>
			</div>
			<div class="file-detail">
				<span class="file-label">Size:</span>
				<span id="file-size">-</span>
			</div>
		</div>
	</div>
	
	<div class="viewer-grid">
		<div class="glass-card hex-output-container">
			<div class="result-header">
				<h3>Hex Dump Output</h3>
				<div class="format-info">16 bytes per line</div>
			</div>
			<div class="hex-display-wrapper">
				<div id="hex-output" class="hex-output"></div>
				<div class="custom-scrollbar" id="custom-scrollbar">
					<div class="scrollbar-track" id="scrollbar-track">
						<div class="scrollbar-thumb" id="scrollbar-thumb"></div>
					</div>
				</div>
			</div>
			<div class="scroll-info">
				<span id="scroll-position">0%</span>
				<span id="offset-info">Offset: 0x00000000</span>
			</div>
		</div>
		
		<div class="glass-card canvas-container">
			<div class="result-header">
				<h3>Visual Representation</h3>
				<div class="format-info">256 bytes per line</div>
			</div>
			<div class="canvas-wrapper">
				<canvas id="hex-canvas" width="256" height="400"></canvas>
				<div class="color-legend">
					<div class="legend-item">
						<div class="color-sample" style="background: #FFFFFF; border: 1px solid var(--border-primary);"></div>
						<span>0x00</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #00FFFF;"></div>
						<span>0x01-0x1F</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #FF0000;"></div>
						<span>0x20-0x7E</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #000000;"></div>
						<span>0x80-0xFF</span>
					</div>
				</div>
			</div>
		</div>
	</div>
	
	<div class="status-bar">
		<span id="status-message">Ready</span>
	</div>
</div>

<script>
	const fileInput = document.getElementById('file-input') as HTMLInputElement;
	const fileName = document.getElementById('file-name') as HTMLSpanElement;
	const fileSize = document.getElementById('file-size') as HTMLSpanElement;
	const hexOutput = document.getElementById('hex-output') as HTMLDivElement;
	const canvas = document.getElementById('hex-canvas') as HTMLCanvasElement;
	const ctx = canvas.getContext('2d')!;
	const customScrollbar = document.getElementById('custom-scrollbar') as HTMLDivElement;
	const scrollbarTrack = document.getElementById('scrollbar-track') as HTMLDivElement;
	const scrollbarThumb = document.getElementById('scrollbar-thumb') as HTMLDivElement;
	const scrollPosition = document.getElementById('scroll-position') as HTMLSpanElement;
	const offsetInfo = document.getElementById('offset-info') as HTMLSpanElement;
	const statusMessage = document.getElementById('status-message') as HTMLSpanElement;

	let currentFile: File | null = null;
	let totalFileSize = 0;
	let currentOffset = 0;
	let isDragging = false;
	let dragStartY = 0;
	let dragStartOffset = 0;
	let isLoading = false;
	let lastUpdateOffset = -1;
	const BYTES_PER_LINE = 16;
	const CANVAS_BYTES_PER_LINE = 256;
	const LINES_TO_DISPLAY = 50;
	const CHUNK_SIZE = LINES_TO_DISPLAY * BYTES_PER_LINE; // Ë°®Á§∫Áî®„ÉÅ„É£„É≥„ÇØ„Çµ„Ç§„Ç∫
	const CANVAS_CHUNK_SIZE = 400 * CANVAS_BYTES_PER_LINE; // CanvasÁî®„ÉÅ„É£„É≥„ÇØ„Çµ„Ç§„Ç∫
	const MIN_THUMB_HEIGHT = 20; // ÊúÄÂ∞è„Çµ„É†„ÅÆÈ´ò„ÅïÔºàpxÔºâ

	function throttle(func: Function, delay: number): Function {
		let timeoutId: number | null = null;
		let lastExecTime = 0;
		return function (...args: any[]) {
			const currentTime = Date.now();
			if (currentTime - lastExecTime > delay) {
				func.apply(this, args);
				lastExecTime = currentTime;
			} else if (!timeoutId) {
				timeoutId = setTimeout(() => {
					func.apply(this, args);
					lastExecTime = Date.now();
					timeoutId = null;
				}, delay - (currentTime - lastExecTime));
			}
		};
	}

	function formatFileSize(bytes: number): string {
		if (bytes === 0) return '0 Bytes';
		const k = 1024;
		const sizes = ['Bytes', 'KB', 'MB', 'GB'];
		const i = Math.floor(Math.log(bytes) / Math.log(k));
		return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
	}

	function byteToHex(byte: number): string {
		return byte.toString(16).padStart(2, '0').toUpperCase();
	}

	function byteToChar(byte: number): string {
		return (byte >= 0x20 && byte <= 0x7E) ? String.fromCharCode(byte) : '.';
	}

	function getByteColor(byte: number): string {
		if (byte === 0x00) return '#FFFFFF';
		if (byte >= 0x01 && byte <= 0x1F) return '#00FFFF';
		if (byte >= 0x20 && byte <= 0x7E) return '#FF0000';
		return '#000000';
	}

	function percentageToOffset(percentage: number): number {
		if (!totalFileSize) return 0;
		const maxOffset = Math.max(0, totalFileSize - CHUNK_SIZE);
		const offset = Math.floor((percentage / 100) * maxOffset);
		return Math.floor(offset / BYTES_PER_LINE) * BYTES_PER_LINE; // Ë°åÂ¢ÉÁïå„Å´ÊèÉ„Åà„Çã
	}

	async function loadChunk(offset: number, size: number): Promise<ArrayBuffer | null> {
		if (!currentFile) return null;
		
		const start = Math.max(0, offset);
		const end = Math.min(currentFile.size, offset + size);
		
		if (start >= end) return null;
		
		try {
			const slice = currentFile.slice(start, end);
			return await slice.arrayBuffer();
		} catch (error) {
			console.error('Error loading chunk:', error);
			return null;
		}
	}

	function updateScrollInfo(percentage: number, offset: number): void {
		scrollPosition.textContent = `${percentage.toFixed(1)}%`;
		offsetInfo.textContent = `Offset: 0x${offset.toString(16).padStart(8, '0').toUpperCase()}`;
	}

	function calculateScrollbarDimensions(): { thumbHeight: number; thumbPosition: number; visible: boolean } {
		if (!totalFileSize || totalFileSize <= CHUNK_SIZE) {
			return { thumbHeight: 0, thumbPosition: 0, visible: false };
		}

		const trackHeight = scrollbarTrack.clientHeight;
		const visibleRatio = CHUNK_SIZE / totalFileSize;
		const thumbHeight = Math.max(MIN_THUMB_HEIGHT, trackHeight * visibleRatio);
		
		const maxOffset = totalFileSize - CHUNK_SIZE;
		const scrollProgress = currentOffset / maxOffset;
		const maxThumbPosition = trackHeight - thumbHeight;
		const thumbPosition = scrollProgress * maxThumbPosition;

		return { thumbHeight, thumbPosition, visible: true };
	}

	function updateScrollbarAppearance(): void {
		const { thumbHeight, thumbPosition, visible } = calculateScrollbarDimensions();
		
		if (visible) {
			customScrollbar.classList.remove('hidden');
			scrollbarThumb.style.height = `${thumbHeight}px`;
			scrollbarThumb.style.top = `${thumbPosition}px`;
		} else {
			customScrollbar.classList.add('hidden');
		}
	}

	function generateHexDump(buffer: ArrayBuffer, fileOffset: number): string {
		const bytes = new Uint8Array(buffer);
		let output = '';

		for (let i = 0; i < bytes.length; i += BYTES_PER_LINE) {
			const actualOffset = fileOffset + i;
			const lineOffset = actualOffset.toString(16).padStart(8, '0').toUpperCase();
			let hexPart = '';
			let textPart = '';

			for (let j = 0; j < BYTES_PER_LINE; j++) {
				const byteIndex = i + j;
				if (byteIndex < bytes.length) {
					const byte = bytes[byteIndex];
					hexPart += byteToHex(byte) + ' ';
					textPart += byteToChar(byte);
				} else {
					hexPart += '   ';
					textPart += ' ';
				}
			}

			output += `${lineOffset}: ${hexPart} |${textPart}|\n`;
		}

		return output;
	}

	function drawCanvas(buffer: ArrayBuffer, offset: number): void {
		const bytes = new Uint8Array(buffer);
		const canvasHeight = canvas.height;
		const bytesPerCanvasLine = CANVAS_BYTES_PER_LINE;
		
		ctx.clearRect(0, 0, canvas.width, canvas.height);

		for (let y = 0; y < canvasHeight; y++) {
			for (let x = 0; x < bytesPerCanvasLine; x++) {
				const bufferIndex = y * bytesPerCanvasLine + x;
				
				if (bufferIndex < bytes.length) {
					const byte = bytes[bufferIndex];
					ctx.fillStyle = getByteColor(byte);
					ctx.fillRect(x, y, 1, 1);
				}
			}
		}
	}

	function setLoadingState(loading: boolean, message: string = 'Ready'): void {
		isLoading = loading;
		if (loading) {
			statusMessage.textContent = message;
			statusMessage.classList.add('loading');
		} else {
			statusMessage.textContent = 'Ready';
			statusMessage.classList.remove('loading');
		}
	}

	async function updateDisplay(): Promise<void> {
		if (!currentFile || isLoading) return;

		// „Ç≠„É£„ÉÉ„Ç∑„É•„ÉÅ„Çß„ÉÉ„ÇØÔºöÂêå„Åò„Ç™„Éï„Çª„ÉÉ„Éà„ÅÆÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
		if (lastUpdateOffset === currentOffset) return;

		setLoadingState(true, 'Loading file data...');
		lastUpdateOffset = currentOffset;

		try {
			// HexdumpÁî®„ÅÆ„ÉÅ„É£„É≥„ÇØ„ÇíË™≠„ÅøËæº„Åø
			const hexBuffer = await loadChunk(currentOffset, CHUNK_SIZE);
			if (hexBuffer) {
				const hexDump = generateHexDump(hexBuffer, currentOffset);
				hexOutput.textContent = hexDump;
			}

			// CanvasÁî®„ÅÆ„ÉÅ„É£„É≥„ÇØ„ÇíË™≠„ÅøËæº„ÅøÔºà„Çà„ÇäÂ§ß„Åç„Å™„ÉÅ„É£„É≥„ÇØÔºâ
			setLoadingState(true, 'Rendering canvas...');
			const canvasBuffer = await loadChunk(currentOffset, CANVAS_CHUNK_SIZE);
			if (canvasBuffer) {
				drawCanvas(canvasBuffer, currentOffset);
				canvas.classList.add('loaded');
			}

			// „Çπ„ÇØ„É≠„Éº„É´ÊÉÖÂ†±„ÇíÊõ¥Êñ∞
			const percentage = totalFileSize > 0 ? (currentOffset / Math.max(1, totalFileSize - CHUNK_SIZE)) * 100 : 0;
			updateScrollInfo(Math.min(percentage, 100), currentOffset);
			updateScrollbarAppearance();

		} catch (error) {
			console.error('Error updating display:', error);
			setLoadingState(false, 'Error loading file');
		} finally {
			setLoadingState(false);
		}
	}

	function handleThumbMouseDown(event: MouseEvent): void {
		if (!currentFile) return;
		
		isDragging = true;
		dragStartY = event.clientY;
		dragStartOffset = currentOffset;
		
		scrollbarThumb.classList.add('dragging');
		document.addEventListener('mousemove', handleThumbMouseMove);
		document.addEventListener('mouseup', handleThumbMouseUp);
		
		event.preventDefault();
	}

	const throttledUpdateDisplay = throttle(updateDisplay, 16); // 60FPSÁõ∏ÂΩì

	function handleThumbMouseMove(event: MouseEvent): void {
		if (!isDragging || !currentFile) return;
		
		const deltaY = event.clientY - dragStartY;
		const trackHeight = scrollbarTrack.clientHeight;
		const { thumbHeight } = calculateScrollbarDimensions();
		const maxThumbPosition = trackHeight - thumbHeight;
		
		if (maxThumbPosition <= 0) return;
		
		const scrollRatio = deltaY / maxThumbPosition;
		const maxOffset = totalFileSize - CHUNK_SIZE;
		const newOffset = dragStartOffset + (scrollRatio * maxOffset);
		
		currentOffset = Math.max(0, Math.min(maxOffset, newOffset));
		currentOffset = Math.floor(currentOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
		
		throttledUpdateDisplay();
	}

	function handleThumbMouseUp(): void {
		if (!isDragging) return;
		
		isDragging = false;
		scrollbarThumb.classList.remove('dragging');
		document.removeEventListener('mousemove', handleThumbMouseMove);
		document.removeEventListener('mouseup', handleThumbMouseUp);
	}

	function handleTrackClick(event: MouseEvent): void {
		if (!currentFile || event.target === scrollbarThumb) return;
		
		const rect = scrollbarTrack.getBoundingClientRect();
		const clickY = event.clientY - rect.top;
		const trackHeight = scrollbarTrack.clientHeight;
		const { thumbHeight } = calculateScrollbarDimensions();
		const maxThumbPosition = trackHeight - thumbHeight;
		
		if (maxThumbPosition <= 0) return;
		
		const scrollRatio = Math.max(0, Math.min(1, clickY / trackHeight));
		const maxOffset = totalFileSize - CHUNK_SIZE;
		currentOffset = Math.floor((scrollRatio * maxOffset) / BYTES_PER_LINE) * BYTES_PER_LINE;
		
		updateDisplay(); // „ÇØ„É™„ÉÉ„ÇØÊôÇ„ÅØÂç≥Â∫ß„Å´Êõ¥Êñ∞
	}

	async function handleFileChange(event: Event): Promise<void> {
		const target = event.target as HTMLInputElement;
		const file = target.files?.[0];
		
		if (!file) {
			currentFile = null;
			totalFileSize = 0;
			currentOffset = 0;
			lastUpdateOffset = -1; // „Ç≠„É£„ÉÉ„Ç∑„É•„É™„Çª„ÉÉ„Éà
			customScrollbar.classList.add('hidden');
			hexOutput.textContent = '';
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			updateScrollInfo(0, 0);
			statusMessage.textContent = 'Ready';
			statusMessage.classList.remove('loading');
			return;
		}

		currentFile = file;
		totalFileSize = file.size;
		currentOffset = 0;
		lastUpdateOffset = -1; // „Ç≠„É£„ÉÉ„Ç∑„É•„É™„Çª„ÉÉ„Éà
		
		fileName.textContent = file.name;
		fileSize.textContent = formatFileSize(file.size);

		try {
			await updateDisplay();
		} catch (error) {
			console.error('Error reading file:', error);
			statusMessage.textContent = 'Error loading file';
			statusMessage.classList.remove('loading');
		}
	}

	fileInput.addEventListener('change', handleFileChange);
	
	// „Éõ„Ç§„Éº„É´„Çπ„ÇØ„É≠„Éº„É´„Éè„É≥„Éâ„É©„Éº
	function handleWheelScroll(event: WheelEvent): void {
		if (!currentFile) return;
		
		event.preventDefault();
		
		const scrollLines = 3; // ‰∏ÄÂ∫¶„Å´„Çπ„ÇØ„É≠„Éº„É´„Åô„ÇãË°åÊï∞
		const scrollAmount = scrollLines * BYTES_PER_LINE;
		const maxOffset = totalFileSize - CHUNK_SIZE;
		
		if (event.deltaY > 0) {
			// ‰∏ã„Çπ„ÇØ„É≠„Éº„É´
			currentOffset = Math.min(maxOffset, currentOffset + scrollAmount);
		} else {
			// ‰∏ä„Çπ„ÇØ„É≠„Éº„É´
			currentOffset = Math.max(0, currentOffset - scrollAmount);
		}
		
		currentOffset = Math.floor(currentOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
		throttledUpdateDisplay();
	}

	// „Ç≠„Éº„Éú„Éº„ÉâÊìç‰Ωú„Éè„É≥„Éâ„É©„Éº
	function handleKeyDown(event: KeyboardEvent): void {
		if (!currentFile) return;
		
		const maxOffset = totalFileSize - CHUNK_SIZE;
		const pageSize = LINES_TO_DISPLAY * BYTES_PER_LINE;
		
		let handled = false;
		
		switch (event.key) {
			case 'ArrowUp':
				currentOffset = Math.max(0, currentOffset - BYTES_PER_LINE);
				handled = true;
				break;
			case 'ArrowDown':
				currentOffset = Math.min(maxOffset, currentOffset + BYTES_PER_LINE);
				handled = true;
				break;
			case 'PageUp':
				currentOffset = Math.max(0, currentOffset - pageSize);
				handled = true;
				break;
			case 'PageDown':
				currentOffset = Math.min(maxOffset, currentOffset + pageSize);
				handled = true;
				break;
			case 'Home':
				currentOffset = 0;
				handled = true;
				break;
			case 'End':
				currentOffset = maxOffset;
				handled = true;
				break;
		}
		
		if (handled) {
			event.preventDefault();
			currentOffset = Math.floor(currentOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
			throttledUpdateDisplay();
		}
	}

	// „Çπ„ÇØ„É≠„Éº„É´„Éê„Éº„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
	scrollbarThumb.addEventListener('mousedown', handleThumbMouseDown);
	scrollbarTrack.addEventListener('click', handleTrackClick);
	
	// hex-output„Ç®„É™„Ç¢„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
	hexOutput.addEventListener('wheel', handleWheelScroll, { passive: false });
	
	// „Ç≠„Éº„Éú„Éº„Éâ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºÔºà„Éï„Ç©„Éº„Ç´„Çπ„ÅåÂøÖË¶ÅÔºâ
	hexOutput.setAttribute('tabindex', '0');
	hexOutput.addEventListener('keydown', handleKeyDown);
</script>

<style>
	.file-info {
		display: flex;
		gap: 2rem;
		margin-top: 1rem;
	}

	.file-detail {
		display: flex;
		gap: 0.5rem;
		align-items: center;
	}

	.file-label {
		font-weight: 500;
		color: var(--text-secondary);
		min-width: 3rem;
	}

	#file-name {
		font-weight: 500;
		color: var(--text-primary);
		font-family: var(--font-mono);
		font-size: 0.875rem;
	}

	#file-size {
		color: var(--text-accent);
		font-family: var(--font-mono);
		font-size: 0.875rem;
	}

	.viewer-grid {
		display: grid;
		grid-template-columns: 1fr 300px;
		gap: 1.5rem;
		margin-top: 1.5rem;
	}

	.hex-output-container {
		max-height: 800px;
		display: flex;
		flex-direction: column;
	}

	.hex-display-wrapper {
		flex: 1;
		display: flex;
		margin-top: 1rem;
		gap: 0; /* „Çπ„ÇØ„É≠„Éº„É´„Éê„Éº„ÇíÈöôÈñì„Å™„ÅèÈÖçÁΩÆ */
	}

	.hex-output {
		flex: 1;
		font-family: var(--font-mono);
		font-size: 0.8rem;
		line-height: 1.4;
		color: var(--text-primary);
		white-space: pre;
		padding: 1rem;
		background: var(--bg-tertiary);
		border-radius: var(--radius-md);
		border: 1px solid var(--border-primary);
		max-height: 600px;
		overflow: hidden; /* ÂÜÖËîµ„Çπ„ÇØ„É≠„Éº„É´„ÇíÁÑ°ÂäπÂåñ */
		border-top-right-radius: 0;
		border-bottom-right-radius: 0;
		border-right: none;
	}

	.custom-scrollbar {
		width: 12px;
		background: var(--bg-tertiary);
		border: 1px solid var(--border-primary);
		border-left: none;
		border-top-right-radius: var(--radius-md);
		border-bottom-right-radius: var(--radius-md);
		position: relative;
		max-height: 600px;
	}

	.custom-scrollbar.hidden {
		display: none;
	}

	.scrollbar-track {
		position: absolute;
		top: 2px;
		left: 2px;
		right: 2px;
		bottom: 2px;
		background: #f1f5f9;
		border-radius: 4px;
		cursor: pointer;
	}

	.scrollbar-thumb {
		position: absolute;
		left: 0;
		right: 0;
		background: #cbd5e1;
		border-radius: 4px;
		cursor: pointer;
		transition: background-color 0.2s ease;
		min-height: 20px;
		opacity: 0.8;
	}

	.scrollbar-thumb:hover {
		background: #94a3b8;
		opacity: 1;
	}

	.scrollbar-thumb.dragging {
		background: #64748b;
		opacity: 1;
	}

	.scroll-info {
		display: flex;
		justify-content: space-between;
		margin-top: 0.5rem;
		font-size: 0.75rem;
		color: var(--text-secondary);
		font-family: var(--font-mono);
	}

	.canvas-container {
		display: flex;
		flex-direction: column;
		max-height: 800px;
	}

	.canvas-wrapper {
		flex: 1;
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 1rem;
		margin-top: 1rem;
	}

	#hex-canvas {
		border: 1px solid var(--border-primary);
		border-radius: var(--radius-sm);
		image-rendering: pixelated;
		background: var(--bg-tertiary);
		box-shadow: var(--shadow-md);
		transition: box-shadow 0.2s ease;
	}

	#hex-canvas:hover {
		box-shadow: var(--shadow-lg);
	}

	.color-legend {
		display: grid;
		grid-template-columns: repeat(2, 1fr);
		gap: 0.5rem;
		width: 100%;
		max-width: 256px;
	}

	.legend-item {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		font-size: 0.75rem;
		color: var(--text-secondary);
	}

	.color-sample {
		width: 12px;
		height: 12px;
		border-radius: 2px;
		flex-shrink: 0;
	}

	.format-info {
		font-size: 0.75rem;
		color: var(--text-muted);
		font-family: var(--font-mono);
	}



	/* Status bar */
	.status-bar {
		margin-top: 1rem;
		padding: 0.5rem 1rem;
		background: var(--bg-tertiary);
		border: 1px solid var(--border-primary);
		border-radius: var(--radius-md);
		display: flex;
		align-items: center;
		min-height: 2rem;
	}

	#status-message {
		font-size: 0.875rem;
		color: var(--text-secondary);
		font-family: var(--font-mono);
	}

	#status-message.loading {
		color: var(--accent-primary);
		position: relative;
	}

	#status-message.loading::after {
		content: '';
		width: 12px;
		height: 12px;
		border: 2px solid var(--border-primary);
		border-top: 2px solid var(--accent-primary);
		border-radius: 50%;
		animation: spin 1s linear infinite;
		margin-left: 0.5rem;
		display: inline-block;
	}

	@keyframes spin {
		0% { transform: rotate(0deg); }
		100% { transform: rotate(360deg); }
	}

	/* Empty state */
	.hex-output:empty::before {
		content: 'Select a file to view its hex dump...';
		color: var(--text-muted);
		font-style: italic;
		display: flex;
		align-items: center;
		justify-content: center;
		height: 100%;
	}

	/* Animation for canvas */
	@keyframes canvasLoad {
		0% {
			opacity: 0;
			transform: scale(0.9);
		}
		100% {
			opacity: 1;
			transform: scale(1);
		}
	}

	#hex-canvas.loaded {
		animation: canvasLoad 0.3s ease-out;
	}

	/* Hover effects */
	.glass-card:hover {
		transform: translateY(-2px);
	}

	.result-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 0;
		padding-bottom: 0;
	}

	.result-header h3 {
		margin: 0;
		font-size: 1.1rem;
	}

	/* File input enhancements */
	.file-input:hover .file-input-label {
		border-color: var(--accent-primary);
		background: var(--bg-card);
		color: var(--text-primary);
	}

	.file-input.has-file .file-input-label {
		border-color: var(--accent-success);
		background: var(--bg-card);
		color: var(--accent-success);
	}
</style>