---

---

<div class="tool-container">
	<div class="tool-header">
		<h1>ğŸ“Š Hex Dump Tool</h1>
		<p>
			Binary file analysis with hexdump display and visual representation
		</p>
	</div>

	<div class="glass-card tool-controls">
		<div class="file-input">
			<input type="file" id="file-input" accept="*/*" />
			<div class="file-input-label">
				<span>ğŸ“ Choose Binary File</span>
			</div>
		</div>
		<div class="file-info">
			<div class="file-detail">
				<span class="file-label">File:</span>
				<span id="file-name">No file selected</span>
			</div>
			<div class="file-detail">
				<span class="file-label">Size:</span>
				<span id="file-size">-</span>
			</div>
		</div>
	</div>

	<div class="glass-card search-panel">
		<div class="search-controls">
			<div class="search-input-group">
				<input type="text" id="search-input" class="search-input" placeholder="Enter search pattern..." />
				<div class="search-mode">
					<label class="search-mode-option">
						<input type="radio" name="search-mode" value="ascii" checked />
						<span>ASCII</span>
					</label>
					<label class="search-mode-option">
						<input type="radio" name="search-mode" value="hex" />
						<span>Hex</span>
					</label>
				</div>
			</div>
			<button id="search-toggle-btn" class="btn btn-primary" disabled>
				<span id="search-btn-text">Search</span>
			</button>
		</div>
	</div>

	<div class="viewer-grid">
		<div class="glass-card hex-output-container">
			<div class="result-header">
				<h3>Hex Dump Output</h3>
				<div class="format-info">16 bytes per line</div>
			</div>
			<div class="hex-display-wrapper">
				<div id="hex-output" class="hex-output"></div>
				<div class="custom-scrollbar" id="custom-scrollbar">
					<div class="scrollbar-track" id="scrollbar-track">
						<div class="scrollbar-thumb" id="scrollbar-thumb"></div>
					</div>
				</div>
			</div>
			<div class="scroll-info">
				<span id="scroll-position">0%</span>
				<span id="offset-info">Offset: 0x00000000</span>
			</div>
		</div>

		<div class="glass-card canvas-container">
			<div class="result-header">
				<h3>Visual Representation</h3>
				<div class="format-info">256 bytes per line</div>
			</div>
			<div class="canvas-wrapper">
				<canvas id="hex-canvas" width="256" height="400"></canvas>
				<div class="color-legend">
					<div class="legend-item">
						<div
							class="color-sample"
							style="background: #FFFFFF; border: 1px solid var(--border-primary);"
						>
						</div>
						<span>0x00</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #00FFFF;">
						</div>
						<span>0x01-0x1F</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #FF0000;">
						</div>
						<span>0x20-0x7E</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #000000;">
						</div>
						<span>0x80-0xFF</span>
					</div>
				</div>
			</div>
		</div>
	</div>

	<div class="status-bar">
		<span id="status-message">Ready</span>
	</div>
	
	<!-- ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
	<div id="drag-overlay" class="drag-overlay hidden">
		<div class="drag-message">
			<div class="drag-icon">ğŸ“</div>
			<div class="drag-text">Drop file here to analyze</div>
		</div>
	</div>
</div>

<script>
	const fileInput = document.getElementById("file-input") as HTMLInputElement;
	const fileName = document.getElementById("file-name") as HTMLSpanElement;
	const fileSize = document.getElementById("file-size") as HTMLSpanElement;
	const hexOutput = document.getElementById("hex-output") as HTMLDivElement;
	const canvas = document.getElementById("hex-canvas") as HTMLCanvasElement;
	const ctx = canvas.getContext("2d", { willReadFrequently: false })!;

	// Canvasæç”»ã®æœ€é©åŒ–è¨­å®š
	ctx.imageSmoothingEnabled = false;
	const customScrollbar = document.getElementById(
		"custom-scrollbar",
	) as HTMLDivElement;
	const scrollbarTrack = document.getElementById(
		"scrollbar-track",
	) as HTMLDivElement;
	const scrollbarThumb = document.getElementById(
		"scrollbar-thumb",
	) as HTMLDivElement;
	const scrollPosition = document.getElementById(
		"scroll-position",
	) as HTMLSpanElement;
	const offsetInfo = document.getElementById(
		"offset-info",
	) as HTMLSpanElement;
	const statusMessage = document.getElementById(
		"status-message",
	) as HTMLSpanElement;
	const dragOverlay = document.getElementById("drag-overlay") as HTMLDivElement;
	
	
	// æ¤œç´¢é–¢é€£ã®è¦ç´ 
	const searchInput = document.getElementById("search-input") as HTMLInputElement;
	const searchToggleBtn = document.getElementById("search-toggle-btn") as HTMLButtonElement;
	const searchBtnText = document.getElementById("search-btn-text") as HTMLSpanElement;
	const searchModeInputs = document.querySelectorAll('input[name="search-mode"]') as NodeListOf<HTMLInputElement>;

	let currentFile: File | null = null;
	let totalFileSize = 0;
	let currentOffset = 0;
	let isDragging = false;
	let dragStartY = 0;
	let dragStartOffset = 0;
	let isLoading = false;
	let lastUpdateOffset = -1;
	let dragCounter = 0; // ãƒ‰ãƒ©ãƒƒã‚°ã‚¤ãƒ™ãƒ³ãƒˆã®é‡è¤‡é˜²æ­¢
	
	// Canvaså°‚ç”¨ã®çŠ¶æ…‹å¤‰æ•°
	let canvasCurrentOffset = 0;
	let lastCanvasUpdateOffset = -1;
	
	// åŒæ–¹å‘åŒæœŸåˆ¶å¾¡ç”¨ãƒ•ãƒ©ã‚°
	let isSyncingToCanvas = false;
	let isSyncingToHexDump = false;
	
	// æ¤œç´¢é–¢é€£ã®çŠ¶æ…‹å¤‰æ•°
	let isSearching = false;
	let searchResultOffset = -1;
	let searchPattern: Uint8Array | null = null;
	let searchWorker: Worker | null = null;
	
	const BYTES_PER_LINE = 16;
	const CANVAS_BYTES_PER_LINE = 256;
	let LINES_TO_DISPLAY = 50; // å‹•çš„ã«å¤‰æ›´ã•ã‚Œã‚‹
	let CHUNK_SIZE = LINES_TO_DISPLAY * BYTES_PER_LINE; // è¡¨ç¤ºç”¨ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚º
	
	// Canvaså°‚ç”¨ã®è¨­å®š
	let CANVAS_LINES_TO_DISPLAY = 400; // Canvasè¡¨ç¤ºè¡Œæ•°ï¼ˆãƒ”ã‚¯ã‚»ãƒ«é«˜ã«å¯¾å¿œï¼‰
	let CANVAS_CHUNK_SIZE = CANVAS_LINES_TO_DISPLAY * CANVAS_BYTES_PER_LINE; // Canvasç”¨ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚º
	
	const MIN_THUMB_HEIGHT = 20; // æœ€å°ã‚µãƒ ã®é«˜ã•ï¼ˆpxï¼‰
	const MIN_LINES = 10; // æœ€å°è¡¨ç¤ºè¡Œæ•°
	const MAX_LINES = 100; // æœ€å¤§è¡¨ç¤ºè¡Œæ•°

	function throttle(func: Function, delay: number): Function {
		let timeoutId: number | null | NodeJS.Timeout = null;
		let lastExecTime = 0;
		return function (...args: any[]) {
			const currentTime = Date.now();
			if (currentTime - lastExecTime > delay) {
				func(...args);
				lastExecTime = currentTime;
			} else if (!timeoutId) {
				timeoutId = setTimeout(
					() => {
						func(...args);
						lastExecTime = Date.now();
						timeoutId = null;
					},
					delay - (currentTime - lastExecTime),
				);
			}
		};
	}

	function calculateVisibleLines(): number {
		try {
			// hex-display-wrapperè¦ç´ ã®å®Ÿéš›ã®é«˜ã•ã‚’å–å¾—
			const wrapper = document.querySelector('.hex-display-wrapper') as HTMLElement;
			if (!wrapper) {
				return 35; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
			}

			const wrapperHeight = wrapper.clientHeight;
			if (wrapperHeight === 0) {
				return 35; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
			}

			// hex-outputè¦ç´ ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è€ƒæ…®
			const padding = 32; // 1rem Ã— 2 (top/bottom padding)
			const availableHeight = wrapperHeight - padding;

			// 1è¡Œã®é«˜ã•ã‚’è¨ˆç®—ï¼ˆfont-size: 0.8rem, line-height: 1.4ï¼‰
			const fontSize = 0.8 * 16; // 0.8rem â†’ px
			const lineHeight = fontSize * 1.4; // line-height: 1.4

			// è¡¨ç¤ºå¯èƒ½ãªè¡Œæ•°ã‚’è¨ˆç®—
			const visibleLines = Math.floor(availableHeight / lineHeight);

			console.log(`Wrapper height: ${wrapperHeight}px, Available height: ${availableHeight}px, Lines: ${visibleLines}`);

			// æœ€å°å€¤ã¨æœ€å¤§å€¤ã®ç¯„å›²å†…ã«åˆ¶é™
			return Math.max(MIN_LINES, Math.min(MAX_LINES, visibleLines));
		} catch (error) {
			console.warn("Failed to calculate visible lines:", error);
			return 35; // ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
		}
	}

	function updateChunkSize(): void {
		LINES_TO_DISPLAY = calculateVisibleLines();
		CHUNK_SIZE = LINES_TO_DISPLAY * BYTES_PER_LINE;
		console.log(
			`Updated display lines: ${LINES_TO_DISPLAY}, chunk size: ${CHUNK_SIZE}`,
		);
	}

	// åŒæ–¹å‘åŒæœŸç”¨ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆå¤‰æ›é–¢æ•°
	function hexDumpOffsetToCanvasOffset(hexOffset: number): number {
		// HexDumpã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆ16ãƒã‚¤ãƒˆå¢ƒç•Œï¼‰ã‚’Canvasä¸­å¿ƒä½ç½®ï¼ˆ256ãƒã‚¤ãƒˆå¢ƒç•Œï¼‰ã«å¤‰æ›
		// Canvasã®ä¸­å¤®ã«HexDumpã®ä½ç½®ãŒæ¥ã‚‹ã‚ˆã†ã«èª¿æ•´
		const canvasHalfHeight = CANVAS_LINES_TO_DISPLAY / 2;
		const targetCanvasLine = Math.floor(hexOffset / CANVAS_BYTES_PER_LINE);
		const centeredCanvasOffset = Math.max(0, (targetCanvasLine - canvasHalfHeight)) * CANVAS_BYTES_PER_LINE;
		return Math.floor(centeredCanvasOffset / CANVAS_BYTES_PER_LINE) * CANVAS_BYTES_PER_LINE;
	}

	function canvasOffsetToHexDumpOffset(canvasOffset: number): number {
		// Canvasã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’HexDumpã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆ16ãƒã‚¤ãƒˆå¢ƒç•Œï¼‰ã«å¤‰æ›
		// Canvasã®å…ˆé ­è¡Œã«å¯¾å¿œã™ã‚‹HexDumpã‚ªãƒ•ã‚»ãƒƒãƒˆ
		return Math.floor(canvasOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
	}


	function formatFileSize(bytes: number): string {
		if (bytes === 0) return "0 Bytes";
		const k = 1024;
		const sizes = ["Bytes", "KB", "MB", "GB"];
		const i = Math.floor(Math.log(bytes) / Math.log(k));
		return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
	}

	// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Šã®ãŸã‚ã®16é€²æ•°å¤‰æ›ãƒ†ãƒ¼ãƒ–ãƒ«
	// 0x00-0xFF (0-255) ã®å…¨ã¦ã®ãƒã‚¤ãƒˆå€¤ã‚’äº‹å‰ã«16é€²æ•°æ–‡å­—åˆ—ã«å¤‰æ›
	const HEX_TABLE = Array.from({ length: 256 }, (_, i) => 
		i.toString(16).padStart(2, "0").toUpperCase()
	);

	// HTMLå‚ç…§æ–‡å­—åŒ–ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–ï¼‰
	// HTMLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³æ”»æ’ƒã‚’é˜²ããŸã‚ã€ç‰¹æ®Šæ–‡å­—ã‚’å‚ç…§æ–‡å­—ã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
	const CHAR_TABLE = (() => {
		const table = new Array(256);
		for (let i = 0; i < 256; i++) {
			if (i >= 0x20 && i <= 0x7e) {
				// å°å­—å¯èƒ½ASCIIæ–‡å­—ã ãŒã€HTMLã®ç‰¹æ®Šæ–‡å­—ã¯ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
				switch (i) {
					case 0x3C: // < (less than)
						table[i] = "&lt;";
						break;
					case 0x3E: // > (greater than)
						table[i] = "&gt;";
						break;
					case 0x26: // & (ampersand)
						table[i] = "&amp;";
						break;
					case 0x22: // " (double quote)
						table[i] = "&quot;";
						break;
					case 0x27: // ' (single quote)
						table[i] = "&#x27;";
						break;
					default:
						table[i] = String.fromCharCode(i);
				}
			} else {
				// éå°å­—æ–‡å­—ã¯å…¨ã¦ . (dot) ã§è¡¨ç¤º
				table[i] = ".";
			}
		}
		return table;
	})();

	function byteToHex(byte: number): string {
		return HEX_TABLE[byte];
	}

	function byteToChar(byte: number): string {
		return CHAR_TABLE[byte];
	}


	function getByteColorRGB(byte: number): {
		r: number;
		g: number;
		b: number;
	} {
		if (byte === 0x00) return { r: 255, g: 255, b: 255 }; // ç™½
		if (byte >= 0x01 && byte <= 0x1f) return { r: 0, g: 255, b: 255 }; // æ°´è‰²
		if (byte >= 0x20 && byte <= 0x7e) return { r: 255, g: 0, b: 0 }; // èµ¤
		return { r: 0, g: 0, b: 0 }; // é»’
	}


	async function loadChunk(
		offset: number,
		size: number,
	): Promise<ArrayBuffer | null> {
		if (!currentFile) return null;

		const start = Math.max(0, offset);
		const end = Math.min(currentFile.size, offset + size);

		if (start >= end) return null;

		try {
			const slice = currentFile.slice(start, end);
			return await slice.arrayBuffer();
		} catch (error) {
			console.error("Error loading chunk:", error);
			return null;
		}
	}

	function updateScrollInfo(percentage: number, offset: number): void {
		scrollPosition.textContent = `${percentage.toFixed(1)}%`;
		offsetInfo.textContent = `Offset: 0x${offset.toString(16).padStart(8, "0").toUpperCase()}`;
	}

	function getMaxOffset(): number {
		if (!totalFileSize || totalFileSize <= CHUNK_SIZE) {
			return 0;
		}
		
		// ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€å¾Œã®ãƒã‚¤ãƒˆãŒå«ã¾ã‚Œã‚‹è¡Œã®é–‹å§‹ã‚ªãƒ•ã‚»ãƒƒãƒˆ
		const lastByteOffset = totalFileSize - 1;
		const lastLineStartOffset = Math.floor(lastByteOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
		
		return Math.max(0, lastLineStartOffset);
	}

	function calculateScrollbarDimensions(): {
		thumbHeight: number;
		thumbPosition: number;
		visible: boolean;
	} {
		if (!totalFileSize || totalFileSize <= CHUNK_SIZE) {
			return { thumbHeight: 0, thumbPosition: 0, visible: false };
		}

		const trackHeight = scrollbarTrack.clientHeight;
		const visibleRatio = CHUNK_SIZE / totalFileSize;
		const thumbHeight = Math.max(
			MIN_THUMB_HEIGHT,
			trackHeight * visibleRatio,
		);

		const maxOffset = getMaxOffset();
		const scrollProgress = maxOffset > 0 ? currentOffset / maxOffset : 0;
		const maxThumbPosition = trackHeight - thumbHeight;
		const thumbPosition = scrollProgress * maxThumbPosition;

		return { thumbHeight, thumbPosition, visible: true };
	}

	// Canvaså°‚ç”¨ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é–¢æ•°ç¾¤
	function getCanvasMaxOffset(): number {
		if (!totalFileSize || totalFileSize <= CANVAS_CHUNK_SIZE) {
			return 0;
		}
		
		// Canvasã®æœ€å¾Œã®ãƒã‚¤ãƒˆãŒå«ã¾ã‚Œã‚‹è¡Œã®é–‹å§‹ã‚ªãƒ•ã‚»ãƒƒãƒˆ
		const lastByteOffset = totalFileSize - 1;
		const lastLineStartOffset = Math.floor(lastByteOffset / CANVAS_BYTES_PER_LINE) * CANVAS_BYTES_PER_LINE;
		
		return Math.max(0, lastLineStartOffset);
	}



	async function updateCanvasDisplay(): Promise<void> {
		if (!currentFile || lastCanvasUpdateOffset === canvasCurrentOffset) {
			return;
		}

		lastCanvasUpdateOffset = canvasCurrentOffset;

		try {
			// Canvasç”¨ã®ãƒãƒ£ãƒ³ã‚¯ã‚’èª­ã¿è¾¼ã¿ï¼ˆHexDumpè¡¨ç¤ºã¨ã¯ç‹¬ç«‹ï¼‰
			const canvasBuffer = await loadChunk(
				canvasCurrentOffset,
				CANVAS_CHUNK_SIZE,
			);
			if (canvasBuffer) {
				drawCanvas(canvasBuffer);
				canvas.classList.add("loaded");
			}

			
			// Canvasã‹ã‚‰HexDumpã¸ã®åŒæœŸï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢ï¼‰
			if (!isSyncingToCanvas) {
				isSyncingToHexDump = true;
				const newHexDumpOffset = canvasOffsetToHexDumpOffset(canvasCurrentOffset);
				if (newHexDumpOffset !== currentOffset) {
					currentOffset = newHexDumpOffset;
					await updateDisplay();
				}
				isSyncingToHexDump = false;
			}

		} catch (error) {
			console.error("Error updating canvas display:", error);
		}
	}

	// Canvasè¡¨ç¤ºæ›´æ–°ã®throttledç‰ˆï¼ˆåŒæœŸæ™‚ã®è² è·è»½æ¸›ï¼‰
	const throttledUpdateCanvasDisplay = throttle(updateCanvasDisplay, 100);

	function updateScrollbarAppearance(): void {
		const { thumbHeight, thumbPosition, visible } =
			calculateScrollbarDimensions();

		if (visible) {
			customScrollbar.classList.remove("hidden");
			scrollbarThumb.style.height = `${thumbHeight}px`;
			scrollbarThumb.style.top = `${thumbPosition}px`;
		} else {
			customScrollbar.classList.add("hidden");
		}
	}


	function generateHexDump(buffer: ArrayBuffer, fileOffset: number): string {
		const bytes = new Uint8Array(buffer);
		let output = "";
		for (let i = 0; i < bytes.length; i += BYTES_PER_LINE) {
			const actualOffset = fileOffset + i;
			const lineOffset = actualOffset
				.toString(16)
				.padStart(8, "0")
				.toUpperCase();
			let hexPart = "";
			let textPart = "";

			for (let j = 0; j < BYTES_PER_LINE; j++) {
				const byteIndex = i + j;
				const currentByteOffset = fileOffset + byteIndex;
				
				if (byteIndex < bytes.length) {
					const byte = bytes[byteIndex];
					let hexByte = byteToHex(byte);
					let textByte = byteToChar(byte);
					
					// æ¤œç´¢çµæœã®ãƒã‚¤ãƒ©ã‚¤ãƒˆå‡¦ç†
					if (searchResultOffset !== -1 && searchPattern) {
						const searchEnd = searchResultOffset + searchPattern.length - 1;
						if (currentByteOffset >= searchResultOffset && currentByteOffset <= searchEnd) {
							hexByte = `<span class="search-highlight">${hexByte}</span>`;
							// textByteã¯æ—¢ã«HTMLå‚ç…§æ–‡å­—åŒ–æ¸ˆã¿ãªã®ã§ã€ãã®ã¾ã¾ãƒã‚¤ãƒ©ã‚¤ãƒˆ
							textByte = `<span class="search-highlight">${textByte}</span>`;
						}
					}
					
					hexPart += hexByte + " ";
					textPart += textByte;
				} else {
					hexPart += "   ";
					textPart += " ";
				}
			}

			output += `${lineOffset}: ${hexPart} |${textPart}|\n`;
		}

		return output;
	}

	function drawCanvas(buffer: ArrayBuffer): void {
		const bytes = new Uint8Array(buffer);
		const canvasWidth = canvas.width;
		const canvasHeight = canvas.height;

		// ImageDataã‚’ä½¿ç”¨ã—ãŸæœ€é©åŒ–ã•ã‚ŒãŸæç”»
		const imageData = ctx.createImageData(canvasWidth, canvasHeight);
		const data = imageData.data;

		// èƒŒæ™¯ã‚’é»’ã§åˆæœŸåŒ–ï¼ˆãƒ‡ãƒ¼ã‚¿ãŒãªã„éƒ¨åˆ†ï¼‰
		for (let i = 0; i < data.length; i += 4) {
			data[i] = 0; // Red
			data[i + 1] = 0; // Green
			data[i + 2] = 0; // Blue
			data[i + 3] = 255; // Alpha
		}

		// ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’è‰²æƒ…å ±ã«å¤‰æ›
		const totalPixels = canvasWidth * canvasHeight;
		const bytesToProcess = Math.min(bytes.length, totalPixels);

		for (let i = 0; i < bytesToProcess; i++) {
			const byte = bytes[i];
			const color = getByteColorRGB(byte);
			const pixelIndex = i * 4;

			data[pixelIndex] = color.r; // Red
			data[pixelIndex + 1] = color.g; // Green
			data[pixelIndex + 2] = color.b; // Blue
			data[pixelIndex + 3] = 255; // Alpha
		}

		// ä¸€åº¦ã«å…¨ä½“ã‚’æç”»
		ctx.putImageData(imageData, 0, 0);
	}

	function setLoadingState(
		loading: boolean,
		message: string = "Ready",
	): void {
		isLoading = loading;
		if (loading) {
			statusMessage.textContent = message;
			statusMessage.classList.add("loading");
		} else {
			statusMessage.textContent = "Ready";
			statusMessage.classList.remove("loading");
		}
	}

	async function updateDisplay(): Promise<void> {
		if (!currentFile || isLoading) return;

		// ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯ï¼šåŒã˜ã‚ªãƒ•ã‚»ãƒƒãƒˆã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
		if (lastUpdateOffset === currentOffset) return;

		setLoadingState(true, "Loading file data...");
		lastUpdateOffset = currentOffset;

		try {
			// Hexdumpç”¨ã®ãƒãƒ£ãƒ³ã‚¯ã‚’èª­ã¿è¾¼ã¿ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«çµ‚ç«¯ã‚’è€ƒæ…®ï¼‰
			const remainingBytes = totalFileSize - currentOffset;
			const readSize = Math.min(CHUNK_SIZE, remainingBytes);
			const hexBuffer = await loadChunk(currentOffset, readSize);
			if (hexBuffer) {
				const hexDump = generateHexDump(hexBuffer, currentOffset);
				hexOutput.innerHTML = hexDump; // HTMLã¨ã—ã¦è¡¨ç¤º
			}

			// ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æƒ…å ±ã‚’æ›´æ–°
			const maxOffset = getMaxOffset();
			const percentage = maxOffset > 0 ? (currentOffset / maxOffset) * 100 : 0;
			updateScrollInfo(Math.min(percentage, 100), currentOffset);
			updateScrollbarAppearance();
			
			
			// HexDumpã‹ã‚‰Canvasã¸ã®åŒæœŸï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢ï¼‰
			if (!isSyncingToHexDump) {
				isSyncingToCanvas = true;
				const newCanvasOffset = hexDumpOffsetToCanvasOffset(currentOffset);
				if (newCanvasOffset !== canvasCurrentOffset) {
					canvasCurrentOffset = newCanvasOffset;
					await updateCanvasDisplay();
				}
				isSyncingToCanvas = false;
			}
		} catch (error) {
			console.error("Error updating display:", error);
			setLoadingState(false, "Error loading file");
		} finally {
			setLoadingState(false);
		}
	}

	function handleThumbMouseDown(event: MouseEvent): void {
		if (!currentFile || isSearching) return;

		isDragging = true;
		dragStartY = event.clientY;
		dragStartOffset = currentOffset;

		scrollbarThumb.classList.add("dragging");
		document.addEventListener("mousemove", handleThumbMouseMove);
		document.addEventListener("mouseup", handleThumbMouseUp);

		event.preventDefault();
	}

	const throttledUpdateDisplay = throttle(updateDisplay, 16); // 60FPSç›¸å½“

	function handleThumbMouseMove(event: MouseEvent): void {
		if (!isDragging || !currentFile || isSearching) return;

		const deltaY = event.clientY - dragStartY;
		const trackHeight = scrollbarTrack.clientHeight;
		const { thumbHeight } = calculateScrollbarDimensions();
		const maxThumbPosition = trackHeight - thumbHeight;

		if (maxThumbPosition <= 0) return;

		const scrollRatio = deltaY / maxThumbPosition;
		const maxOffset = getMaxOffset();
		const newOffset = dragStartOffset + scrollRatio * maxOffset;

		currentOffset = Math.max(0, Math.min(maxOffset, newOffset));
		currentOffset =
			Math.floor(currentOffset / BYTES_PER_LINE) * BYTES_PER_LINE;

		throttledUpdateDisplay();
	}

	function handleThumbMouseUp(): void {
		if (!isDragging) return;

		isDragging = false;
		scrollbarThumb.classList.remove("dragging");
		document.removeEventListener("mousemove", handleThumbMouseMove);
		document.removeEventListener("mouseup", handleThumbMouseUp);
	}

	function handleTrackClick(event: MouseEvent): void {
		if (!currentFile || event.target === scrollbarThumb || isSearching) return;

		const rect = scrollbarTrack.getBoundingClientRect();
		const clickY = event.clientY - rect.top;
		const trackHeight = scrollbarTrack.clientHeight;
		const { thumbHeight } = calculateScrollbarDimensions();
		const maxThumbPosition = trackHeight - thumbHeight;

		if (maxThumbPosition <= 0) return;

		const scrollRatio = Math.max(0, Math.min(1, clickY / trackHeight));
		const maxOffset = getMaxOffset();
		currentOffset =
			Math.floor((scrollRatio * maxOffset) / BYTES_PER_LINE) *
			BYTES_PER_LINE;

		updateDisplay(); // ã‚¯ãƒªãƒƒã‚¯æ™‚ã¯å³åº§ã«æ›´æ–°
	}


	function handleCanvasWheelScroll(event: WheelEvent): void {
		if (!currentFile || isSearching) return;

		event.preventDefault();

		// Canvasç”¨ã¯ç”»é¢ã®ç´„1/3ã‚’ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼ˆå¤§å¹…ãªé«˜é€Ÿã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰
		const pageScrollLines = Math.floor(CANVAS_LINES_TO_DISPLAY / 3); // ç´„133è¡Œ
		const scrollAmount = pageScrollLines * CANVAS_BYTES_PER_LINE; // ç´„34,048ãƒã‚¤ãƒˆ
		const maxOffset = getCanvasMaxOffset();

		if (event.deltaY > 0) {
			// ä¸‹ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
			canvasCurrentOffset = Math.min(maxOffset, canvasCurrentOffset + scrollAmount);
		} else {
			// ä¸Šã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
			canvasCurrentOffset = Math.max(0, canvasCurrentOffset - scrollAmount);
		}

		// è¡Œå¢ƒç•Œã«èª¿æ•´
		canvasCurrentOffset = Math.floor(canvasCurrentOffset / CANVAS_BYTES_PER_LINE) * CANVAS_BYTES_PER_LINE;
		
		throttledUpdateCanvasDisplay();
	}

	// ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã‚’ã‚¯ãƒªã‚¢
	function clearFileSelection(): void {
		currentFile = null;
		totalFileSize = 0;
		currentOffset = 0;
		lastUpdateOffset = -1; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒªã‚»ãƒƒãƒˆ
		
		// CanvasçŠ¶æ…‹ã‚‚ãƒªã‚»ãƒƒãƒˆ
		canvasCurrentOffset = 0;
		lastCanvasUpdateOffset = -1;
		
		customScrollbar.classList.add("hidden");
		hexOutput.textContent = "";
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		updateScrollInfo(0, 0);
		setLoadingState(false, "Ready");
		
		// æ¤œç´¢çµæœã‚’ã‚¯ãƒªã‚¢
		searchResultOffset = -1;
		searchPattern = null;
		
		// æ¤œç´¢ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
		updateSearchButtonState();
	}

	// ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å‡¦ç†ï¼ˆå…±é€šï¼‰
	async function loadFile(file: File): Promise<void> {
		currentFile = file;
		totalFileSize = file.size;
		currentOffset = 0;
		lastUpdateOffset = -1; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒªã‚»ãƒƒãƒˆ
		
		// CanvasçŠ¶æ…‹ã‚‚åˆæœŸåŒ–
		canvasCurrentOffset = 0;
		lastCanvasUpdateOffset = -1;

		fileName.textContent = file.name;
		fileSize.textContent = formatFileSize(file.size);

		// è¡¨ç¤ºè¡Œæ•°ã‚’å‹•çš„ã«è¨ˆç®—ã—ã¦æ›´æ–°
		updateChunkSize();
		
		// æ¤œç´¢ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
		updateSearchButtonState();
		
		// æ¤œç´¢çµæœã‚’ã‚¯ãƒªã‚¢
		searchResultOffset = -1;
		searchPattern = null;

		try {
			await updateDisplay();
			await updateCanvasDisplay();
		} catch (error) {
			console.error("Error reading file:", error);
			setLoadingState(false, "Error loading file");
		}
	}

	async function handleFileChange(event: Event): Promise<void> {
		if (isSearching) return;
		
		const target = event.target as HTMLInputElement;
		const file = target.files?.[0];

		if (!file) {
			clearFileSelection();
			return;
		}

		await loadFile(file);
	}

	fileInput.addEventListener("change", handleFileChange);

	// ãƒ›ã‚¤ãƒ¼ãƒ«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
	function handleWheelScroll(event: WheelEvent): void {
		if (!currentFile || isSearching) return;

		event.preventDefault();

		const scrollLines = 3; // ä¸€åº¦ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã™ã‚‹è¡Œæ•°
		const scrollAmount = scrollLines * BYTES_PER_LINE;
		const maxOffset = getMaxOffset();

		if (event.deltaY > 0) {
			// ä¸‹ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
			currentOffset = Math.min(maxOffset, currentOffset + scrollAmount);
		} else {
			// ä¸Šã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
			currentOffset = Math.max(0, currentOffset - scrollAmount);
		}

		currentOffset =
			Math.floor(currentOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
		throttledUpdateDisplay();
	}

	// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œãƒãƒ³ãƒ‰ãƒ©ãƒ¼
	function handleKeyDown(event: KeyboardEvent): void {
		if (!currentFile || isSearching) return;

		const maxOffset = getMaxOffset();
		const pageSize = LINES_TO_DISPLAY * BYTES_PER_LINE;

		let handled = false;

		switch (event.key) {
			case "ArrowUp":
				currentOffset = Math.max(0, currentOffset - BYTES_PER_LINE);
				handled = true;
				break;
			case "ArrowDown":
				currentOffset = Math.min(
					maxOffset,
					currentOffset + BYTES_PER_LINE,
				);
				handled = true;
				break;
			case "PageUp":
				currentOffset = Math.max(0, currentOffset - pageSize);
				handled = true;
				break;
			case "PageDown":
				currentOffset = Math.min(maxOffset, currentOffset + pageSize);
				handled = true;
				break;
			case "Home":
				currentOffset = 0;
				handled = true;
				break;
			case "End":
				currentOffset = maxOffset;
				handled = true;
				break;
		}

		if (handled) {
			event.preventDefault();
			currentOffset =
				Math.floor(currentOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
			throttledUpdateDisplay();
		}
	}

	// ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
	scrollbarThumb.addEventListener("mousedown", handleThumbMouseDown);
	scrollbarTrack.addEventListener("click", handleTrackClick);


	// hex-outputã‚¨ãƒªã‚¢ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
	hexOutput.addEventListener("wheel", handleWheelScroll, { passive: false });
	
	// Canvaså°‚ç”¨ãƒ›ã‚¤ãƒ¼ãƒ«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
	canvas.addEventListener("wheel", handleCanvasWheelScroll, { passive: false });

	// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ï¼ˆãƒ•ã‚©ãƒ¼ã‚«ã‚¹ãŒå¿…è¦ï¼‰
	hexOutput.setAttribute("tabindex", "0");
	hexOutput.addEventListener("keydown", handleKeyDown);

	// åˆæœŸåŒ–æ™‚ã«å‹•çš„è¡Œæ•°ã‚’è¨ˆç®—
	document.addEventListener("DOMContentLoaded", () => {
		// å°‘ã—é…å»¶ã•ã›ã¦è¦ç´ ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’å¾…ã¤
		setTimeout(() => {
			updateChunkSize();
		}, 100);
	});

	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºæ™‚ã®å†è¨ˆç®—ï¼ˆthrottledï¼‰
	const throttledResize = throttle(() => {
		if (currentFile) {
			const oldChunkSize = CHUNK_SIZE;
			updateChunkSize();
			
			// ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚ºãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã¯å†æç”»
			if (CHUNK_SIZE !== oldChunkSize) {
				lastUpdateOffset = -1; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒªã‚»ãƒƒãƒˆ
				updateDisplay();
			}
		}
	}, 250); // ãƒªã‚µã‚¤ã‚ºã¯250msé–“éš”ã§åˆ¶é™

	window.addEventListener("resize", throttledResize as EventListener);

	// Offsetå€¤ã‚¸ãƒ£ãƒ³ãƒ—æ©Ÿèƒ½
	function handleOffsetClick(): void {
		if (!currentFile || isSearching) return;

		const input = prompt(
			"Jump to offset (hexadecimal, e.g., 1000 or 0x1000):",
			"0x" + currentOffset.toString(16).toUpperCase(),
		);

		if (input === null) return; // ã‚­ãƒ£ãƒ³ã‚»ãƒ«

		let targetOffset: number;
		try {
			// 16é€²æ•°ã¨ã—ã¦è§£æï¼ˆ0xãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã®æœ‰ç„¡ã‚’å•ã‚ãªã„ï¼‰
			const cleanInput = input.trim().toLowerCase();
			if (cleanInput.startsWith("0x")) {
				targetOffset = parseInt(cleanInput, 16);
			} else {
				targetOffset = parseInt(cleanInput, 16);
			}

			if (isNaN(targetOffset) || targetOffset < 0) {
				alert("Invalid offset value. Please enter a valid hexadecimal number.");
				return;
			}

			// ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºå†…ã«åˆ¶é™
			const maxOffset = getMaxOffset();
			targetOffset = Math.min(targetOffset, maxOffset);

			// è¡Œå¢ƒç•Œã«æƒãˆã‚‹
			targetOffset = Math.floor(targetOffset / BYTES_PER_LINE) * BYTES_PER_LINE;

			currentOffset = targetOffset;
			lastUpdateOffset = -1; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒªã‚»ãƒƒãƒˆ
			updateDisplay();
		} catch (error) {
			alert("Invalid offset value. Please enter a valid hexadecimal number.");
		}
	}

	// Offsetæƒ…å ±ã‚’ã‚¯ãƒªãƒƒã‚¯å¯èƒ½ã«ã™ã‚‹
	offsetInfo.addEventListener("click", handleOffsetClick);

	// Canvasä¸Šã§ã®ã‚¯ãƒªãƒƒã‚¯ã‚¸ãƒ£ãƒ³ãƒ—æ©Ÿèƒ½
	function handleCanvasClick(event: MouseEvent): void {
		if (!currentFile || isSearching) return;

		const rect = canvas.getBoundingClientRect();
		const x = event.clientX - rect.left;
		const y = event.clientY - rect.top;

		// Canvaså†…ã®åº§æ¨™ã‚’ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ã«å¤‰æ›
		const canvasX = Math.floor(x);
		const canvasY = Math.floor(y);

		// Canvasæç”»é ˜åŸŸå†…ã‹ãƒã‚§ãƒƒã‚¯
		if (canvasX < 0 || canvasX >= canvas.width || canvasY < 0 || canvasY >= canvas.height) {
			return;
		}

		// ã‚¯ãƒªãƒƒã‚¯ä½ç½®ã®ãƒã‚¤ãƒˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
		const bytesPerCanvasLine = CANVAS_BYTES_PER_LINE;
		const byteIndex = canvasY * bytesPerCanvasLine + canvasX;

		// ç¾åœ¨ã®Canvasè¡¨ç¤ºã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è€ƒæ…®ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«å†…ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
		const fileByteOffset = currentOffset + byteIndex;

		// ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºå†…ã‹ãƒã‚§ãƒƒã‚¯
		if (fileByteOffset >= totalFileSize) {
			return;
		}

		// 16ãƒã‚¤ãƒˆå¢ƒç•Œã«ä¸¸ã‚ãŸã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
		const targetOffset = Math.floor(fileByteOffset / BYTES_PER_LINE) * BYTES_PER_LINE;

		// æœ€å¤§ã‚ªãƒ•ã‚»ãƒƒãƒˆå†…ã«åˆ¶é™
		const maxOffset = getMaxOffset();
		const clampedOffset = Math.min(targetOffset, maxOffset);

		// ã‚¸ãƒ£ãƒ³ãƒ—å®Ÿè¡Œ
		if (clampedOffset !== currentOffset) {
			currentOffset = clampedOffset;
			lastUpdateOffset = -1; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒªã‚»ãƒƒãƒˆ
			updateDisplay();
		}
	}

	// Canvasã«ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
	canvas.addEventListener("click", handleCanvasClick);

	// ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½
	function handleDragEnter(event: DragEvent): void {
		if (isSearching) return;
		
		event.preventDefault();
		dragCounter++;
		if (dragCounter === 1) {
			dragOverlay.classList.remove("hidden");
		}
	}

	function handleDragOver(event: DragEvent): void {
		if (isSearching) return;
		
		event.preventDefault();
		event.dataTransfer!.dropEffect = "copy";
	}

	function handleDragLeave(event: DragEvent): void {
		if (isSearching) return;
		
		event.preventDefault();
		dragCounter--;
		if (dragCounter === 0) {
			dragOverlay.classList.add("hidden");
		}
	}

	function handleDrop(event: DragEvent): void {
		if (isSearching) return;
		
		event.preventDefault();
		dragCounter = 0;
		dragOverlay.classList.add("hidden");

		const files = event.dataTransfer?.files;
		if (files && files.length > 0) {
			const file = files[0];
			// å…±é€šã®loadFileé–¢æ•°ã‚’ä½¿ç”¨
			loadFile(file);
		}
	}


	// ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’documentã«è¿½åŠ 
	document.addEventListener("dragenter", handleDragEnter);
	document.addEventListener("dragover", handleDragOver);
	document.addEventListener("dragleave", handleDragLeave);
	document.addEventListener("drop", handleDrop);

	// æ¤œç´¢æ©Ÿèƒ½ã®å®Ÿè£…
	function getCurrentSearchMode(): 'ascii' | 'hex' {
		const checkedInput = document.querySelector('input[name="search-mode"]:checked') as HTMLInputElement;
		return checkedInput?.value as 'ascii' | 'hex' || 'ascii';
	}

	function updateSearchPlaceholder(): void {
		const mode = getCurrentSearchMode();
		if (mode === 'ascii') {
			searchInput.placeholder = 'Enter ASCII text (e.g., "Hello World")';
		} else {
			searchInput.placeholder = 'Enter hex bytes (e.g., "48 65 6C 6C 6F")';
		}
	}

	function validateSearchInput(input: string, mode: 'ascii' | 'hex'): boolean {
		if (!input.trim()) {
			return false;
		}

		if (mode === 'ascii') {
			// ASCIIæ–‡å­—åˆ—ã¯å¸¸ã«æœ‰åŠ¹
			return true;
		} else {
			// 16é€²æ•°ãƒã‚¤ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œè¨¼
			const hexPattern = /^[0-9A-Fa-f\s]+$/;
			if (!hexPattern.test(input)) {
				return false;
			}
			
			// ã‚¹ãƒšãƒ¼ã‚¹ã§åˆ†å‰²ã—ã¦å„ãƒã‚¤ãƒˆã‚’æ¤œè¨¼
			const bytes = input.trim().split(/\s+/);
			return bytes.every(byte => {
				const parsed = parseInt(byte, 16);
				return !isNaN(parsed) && parsed >= 0 && parsed <= 255;
			});
		}
	}

	function convertToBytePattern(input: string, mode: 'ascii' | 'hex'): Uint8Array | null {
		if (!input.trim()) {
			return null;
		}

		try {
			if (mode === 'ascii') {
				// ASCIIæ–‡å­—åˆ—ã‚’ãƒã‚¤ãƒˆé…åˆ—ã«å¤‰æ›
				return new TextEncoder().encode(input);
			} else {
				// 16é€²æ•°æ–‡å­—åˆ—ã‚’ãƒã‚¤ãƒˆé…åˆ—ã«å¤‰æ›
				const bytes = input.trim().split(/\s+/).map(byte => parseInt(byte, 16));
				return new Uint8Array(bytes);
			}
		} catch (error) {
			console.error('Pattern conversion error:', error);
			return null;
		}
	}

	function updateSearchButtonState(): void {
		const input = searchInput.value.trim();
		const mode = getCurrentSearchMode();
		const isValid = validateSearchInput(input, mode);
		
		if (isValid) {
			searchInput.classList.remove('invalid');
			searchToggleBtn.disabled = !currentFile;
		} else {
			searchInput.classList.add('invalid');
			searchToggleBtn.disabled = true;
		}
		
		// ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’æ›´æ–°
		if (isSearching) {
			searchBtnText.textContent = 'Stop';
			searchToggleBtn.className = 'btn btn-secondary';
		} else {
			searchBtnText.textContent = 'Search';
			searchToggleBtn.className = 'btn btn-primary';
		}
		
		// æ¤œç´¢ä¸­ã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã¨ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã‚’ç„¡åŠ¹åŒ–
		if (isSearching) {
			customScrollbar.classList.add('disabled');
			fileInput.disabled = true;
		} else {
			customScrollbar.classList.remove('disabled');
			fileInput.disabled = false;
		}
	}

	// æ¤œç´¢å…¥åŠ›ã®å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆ
	searchInput.addEventListener('input', updateSearchButtonState);

	// æ¤œç´¢ãƒ¢ãƒ¼ãƒ‰ã®å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆ
	searchModeInputs.forEach(input => {
		input.addEventListener('change', () => {
			updateSearchPlaceholder();
			updateSearchButtonState();
		});
	});

	// åˆæœŸåŒ–
	updateSearchPlaceholder();
	updateSearchButtonState();

	// Web Workerã‚’åˆæœŸåŒ–
	function initializeSearchWorker(): void {
		if (!searchWorker) {
			// åŒã˜éšå±¤ã®Workerãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
			const workerScript = new URL('./HexDumpSearchWorker.js', import.meta.url);
			searchWorker = new Worker(workerScript, { type: 'module' });
			searchWorker.onmessage = handleWorkerMessage;
			searchWorker.onerror = (error) => {
				console.error('HexDump search worker error:', error);
				statusMessage.textContent = 'Search worker error occurred';
				statusMessage.classList.add('error');
				isSearching = false;
				updateSearchButtonState();
			};
		}
	}

	// Workerã‹ã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡¦ç†
	function handleWorkerMessage(event: MessageEvent): void {
		const data = event.data;
		const type = data.type;
		
		switch (type) {
			case 'progress':
				// æ¨å®šæ®‹ã‚Šæ™‚é–“ã‚’åˆ†ã‹ã‚Šã‚„ã™ãè¡¨ç¤º
				const remainingSeconds = Math.ceil(data.estimatedRemainingMs / 1000);
				let timeText = '';
				
				if (remainingSeconds < 60) {
					timeText = `~${remainingSeconds}s`;
				} else if (remainingSeconds < 3600) {
					const minutes = Math.ceil(remainingSeconds / 60);
					timeText = `~${minutes}m`;
				} else {
					const hours = Math.floor(remainingSeconds / 3600);
					const minutes = Math.ceil((remainingSeconds % 3600) / 60);
					timeText = `~${hours}h${minutes}m`;
				}
				
				statusMessage.textContent = `Searching... ${data.progress.toFixed(1)}% (${timeText} remaining)`;
				break;
				
			case 'found':
				// æ¤œç´¢æˆåŠŸ
				searchResultOffset = data.offset;
				statusMessage.textContent = `Found at offset 0x${data.offset.toString(16).toUpperCase()}`;
				statusMessage.classList.remove('loading');
				statusMessage.classList.add('success');
				
				// çµæœã®ä½ç½®ã«ã‚¸ãƒ£ãƒ³ãƒ—ã—ã¦ã‹ã‚‰finishSearchã‚’å‘¼ã¶
				jumpToOffset(data.offset);
				
				// æ¤œç´¢çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢ï¼ˆãƒã‚¤ãƒ©ã‚¤ãƒˆã¯æ®‹ã™ï¼‰
				isSearching = false;
				updateSearchButtonState();
				
				// 3ç§’å¾Œã«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
				setTimeout(() => {
					statusMessage.textContent = 'Ready';
					statusMessage.classList.remove('success', 'warning', 'error');
				}, 3000);
				break;
				
			case 'not_found':
				// è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸ
				statusMessage.textContent = 'Pattern not found';
				statusMessage.classList.remove('loading');
				statusMessage.classList.add('warning');
				finishSearch();
				break;
				
			case 'cancelled':
				// æ¤œç´¢ã‚­ãƒ£ãƒ³ã‚»ãƒ«
				statusMessage.textContent = 'Search cancelled';
				statusMessage.classList.remove('loading');
				finishSearch();
				break;
				
			default:
				console.warn('Unknown worker message type:', type);
		}
	}


	// æ¤œç´¢å®Œäº†å‡¦ç†
	function finishSearch(): void {
		isSearching = false;
		updateSearchButtonState();
		
		// 3ç§’å¾Œã«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
		setTimeout(() => {
			statusMessage.textContent = 'Ready';
			statusMessage.classList.remove('success', 'warning', 'error');
		}, 3000);
	}

	// åˆæœŸåŒ–æ™‚ã«Workerã‚’ä½œæˆ
	initializeSearchWorker();


	// æ¤œç´¢å®Ÿè¡Œé–¢æ•°ï¼ˆWeb Workerãƒ™ãƒ¼ã‚¹ï¼‰
	async function executeSearch(): Promise<void> {
		const input = searchInput.value.trim();
		const mode = getCurrentSearchMode();
		
		if (!input || !currentFile || !searchWorker) {
			return;
		}

		// æ¤œç´¢ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å¤‰æ›
		const pattern = convertToBytePattern(input, mode);
		if (!pattern) {
			statusMessage.textContent = 'Invalid search pattern';
			statusMessage.classList.add('error');
			setTimeout(() => {
				statusMessage.textContent = 'Ready';
				statusMessage.classList.remove('error');
			}, 3000);
			return;
		}

		// å‰å›ã®æ¤œç´¢çµæœã‚’ã‚¯ãƒªã‚¢ï¼ˆæ–°ã—ã„æ¤œç´¢é–‹å§‹æ™‚ã®ã¿ï¼‰
		searchResultOffset = -1;
		
		// æ¤œç´¢çŠ¶æ…‹ã‚’è¨­å®š
		isSearching = true;
		searchPattern = pattern;
		
		// UIçŠ¶æ…‹ã‚’æ›´æ–°
		updateSearchButtonState();
		statusMessage.textContent = 'Searching...';
		statusMessage.classList.add('loading');
		
		// è¡¨ç¤ºã‚’æ›´æ–°ã—ã¦ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ã‚¯ãƒªã‚¢
		updateDisplay();

		// Web Workerã«æ¤œç´¢ã‚’ä¾é ¼ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå«ã‚€ï¼‰
		searchWorker.postMessage({
			type: 'search',
			data: {
				file: currentFile, // ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç›´æ¥é€ä¿¡
				pattern: Array.from(pattern), // Uint8Arrayã‚’é…åˆ—ã«å¤‰æ›
				startOffset: currentOffset,
				chunkSize: 4 * 1024 * 1024 // 4MB chunksï¼ˆI/OåŠ¹ç‡å‘ä¸Šï¼‰
			}
		});
	}

	// æ¤œç´¢åœæ­¢é–¢æ•°ï¼ˆWeb Workerãƒ™ãƒ¼ã‚¹ï¼‰
	function stopSearch(): void {
		if (searchWorker && isSearching) {
			searchWorker.postMessage({
				type: 'cancel'
			});
		}
	}

	// ã‚ªãƒ•ã‚»ãƒƒãƒˆã«ã‚¸ãƒ£ãƒ³ãƒ—ã™ã‚‹é–¢æ•°
	function jumpToOffset(targetOffset: number): void {
		const maxOffset = getMaxOffset();
		const clampedOffset = Math.min(targetOffset, maxOffset);
		const alignedOffset = Math.floor(clampedOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
		
		currentOffset = alignedOffset;
		lastUpdateOffset = -1; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒªã‚»ãƒƒãƒˆ
		updateDisplay();
	}

	// æ¤œç´¢ãƒˆã‚°ãƒ«ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
	searchToggleBtn.addEventListener('click', () => {
		if (isSearching) {
			stopSearch();
		} else {
			executeSearch();
		}
	});

	// Enterã‚­ãƒ¼ã§ã®æ¤œç´¢å®Ÿè¡Œ
	searchInput.addEventListener('keydown', (event) => {
		if (event.key === 'Enter' && !searchToggleBtn.disabled) {
			if (isSearching) {
				stopSearch();
			} else {
				executeSearch();
			}
		}
	});

</script>

<style>
	.file-info {
		display: flex;
		gap: 2rem;
		margin-top: 1rem;
	}

	.file-detail {
		display: flex;
		gap: 0.5rem;
		align-items: center;
	}

	.file-label {
		font-weight: 500;
		color: var(--text-secondary);
		min-width: 3rem;
	}

	#file-name {
		font-weight: 500;
		color: var(--text-primary);
		font-family: var(--font-mono);
		font-size: 0.875rem;
	}

	#file-size {
		color: var(--text-accent);
		font-family: var(--font-mono);
		font-size: 0.875rem;
	}

	.viewer-grid {
		display: grid;
		grid-template-columns: 1fr 300px;
		gap: 1.5rem;
		margin-top: 1.5rem;
	}

	.hex-output-container {
		height: calc(100vh - 400px); /* ãƒ˜ãƒƒãƒ€ãƒ¼ã‚„ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®é«˜ã•ã‚’è€ƒæ…® */
		max-height: 800px;
		min-height: 400px; /* æœ€å°é«˜ã•ã‚’ä¿è¨¼ */
		display: flex;
		flex-direction: column;
	}

	.hex-display-wrapper {
		flex: 1;
		display: flex;
		margin-top: 1rem;
		gap: 0; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚’éš™é–“ãªãé…ç½® */
		min-height: 0; /* flexboxã§é©åˆ‡ã«ç¸®å°ã•ã‚Œã‚‹ã‚ˆã†ã« */
		overflow: hidden; /* å†…å®¹ãŒã¯ã¿å‡ºãªã„ã‚ˆã†ã« */
	}

	.hex-output {
		flex: 1;
		font-family: var(--font-mono);
		font-size: 0.8rem;
		line-height: 1.4;
		color: var(--text-primary);
		white-space: pre;
		padding: 1rem;
		background: var(--bg-tertiary);
		border-radius: var(--radius-md);
		border: 1px solid var(--border-primary);
		overflow: hidden; /* å†…è”µã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç„¡åŠ¹åŒ– */
		border-top-right-radius: 0;
		border-bottom-right-radius: 0;
		border-right: none;
		min-height: 200px; /* æœ€å°é«˜ã•ã‚’è¨­å®š */
	}

	.custom-scrollbar {
		width: 12px;
		background: var(--bg-tertiary);
		border: 1px solid var(--border-primary);
		border-left: none;
		border-top-right-radius: var(--radius-md);
		border-bottom-right-radius: var(--radius-md);
		position: relative;
		height: 100%; /* è¦ªè¦ç´ ã®é«˜ã•ã«åˆã‚ã›ã‚‹ */
	}

	.custom-scrollbar.hidden {
		display: none;
	}

	.custom-scrollbar.disabled {
		opacity: 0.5;
		pointer-events: none;
	}

	.scrollbar-track {
		position: absolute;
		top: 2px;
		left: 2px;
		right: 2px;
		bottom: 2px;
		background: var(--bg-secondary);
		border-radius: 4px;
		cursor: pointer;
	}

	.scrollbar-thumb {
		position: absolute;
		left: 0;
		right: 0;
		background: var(--text-muted);
		border-radius: 4px;
		cursor: pointer;
		transition: background-color 0.2s ease;
		min-height: 20px;
		opacity: 0.8;
	}

	.scrollbar-thumb:hover {
		background: var(--text-secondary);
		opacity: 1;
	}

	.scrollbar-thumb.dragging {
		background: var(--accent-primary);
		opacity: 1;
	}

	.scroll-info {
		display: flex;
		justify-content: space-between;
		margin-top: 0.5rem;
		padding: 0.5rem 0;
		font-size: 0.75rem;
		color: var(--text-secondary);
		font-family: var(--font-mono);
		flex-shrink: 0; /* flexboxã§ç¸®å°ã•ã‚Œãªã„ã‚ˆã†ã« */
		border-top: 1px solid var(--border-secondary);
	}

	#offset-info {
		cursor: pointer;
		padding: 0.25rem 0.5rem;
		border-radius: var(--radius-sm);
		transition: all 0.2s ease;
	}

	#offset-info:hover {
		background: var(--bg-card);
		color: var(--accent-primary);
		transform: translateY(-1px);
	}


	.canvas-container {
		display: flex;
		flex-direction: column;
		max-height: 800px;
	}


	#hex-canvas {
		border: 1px solid var(--border-primary);
		image-rendering: pixelated;
		background: var(--bg-tertiary);
		box-shadow: var(--shadow-md);
		transition: box-shadow 0.2s ease;
		cursor: pointer;
	}

	#hex-canvas:hover {
		box-shadow: var(--shadow-lg), 0 0 10px rgba(59, 130, 246, 0.3);
		border-color: var(--accent-primary);
	}

	.color-legend {
		display: grid;
		grid-template-columns: repeat(2, 1fr);
		gap: 0.5rem;
		width: 100%;
		max-width: 256px;
	}

	.legend-item {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		font-size: 0.75rem;
		color: var(--text-secondary);
	}

	.color-sample {
		width: 12px;
		height: 12px;
		border-radius: 2px;
		flex-shrink: 0;
	}

	.format-info {
		font-size: 0.75rem;
		color: var(--text-muted);
		font-family: var(--font-mono);
	}

	/* Canvaså°‚ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
	.canvas-wrapper {
		flex: 1;
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 1rem;
		margin-top: 1rem;
	}

	/* Status bar */
	.status-bar {
		margin-top: 1rem;
		padding: 0.5rem 1rem;
		background: var(--bg-tertiary);
		border: 1px solid var(--border-primary);
		border-radius: var(--radius-md);
		display: flex;
		align-items: center;
		min-height: 2rem;
	}

	#status-message {
		font-size: 0.875rem;
		color: var(--text-secondary);
		font-family: var(--font-mono);
	}

	#status-message.loading {
		color: var(--accent-primary);
		position: relative;
	}

	#status-message.loading::after {
		content: "";
		width: 12px;
		height: 12px;
		border: 2px solid var(--border-primary);
		border-top: 2px solid var(--accent-primary);
		border-radius: 50%;
		animation: spin 1s linear infinite;
		margin-left: 0.5rem;
		display: inline-block;
	}

	#status-message.success {
		color: var(--accent-success);
	}

	#status-message.warning {
		color: var(--accent-warning);
	}

	#status-message.error {
		color: var(--accent-error);
	}

	@keyframes spin {
		0% {
			transform: rotate(0deg);
		}
		100% {
			transform: rotate(360deg);
		}
	}

	/* Empty state */
	.hex-output:empty::before {
		content: "Select a file to view its hex dump...";
		color: var(--text-muted);
		font-style: italic;
		display: flex;
		align-items: center;
		justify-content: center;
		height: 100%;
	}

	/* Animation for canvas */
	@keyframes canvasLoad {
		0% {
			opacity: 0;
			transform: scale(0.9);
		}
		100% {
			opacity: 1;
			transform: scale(1);
		}
	}

	#hex-canvas.loaded {
		animation: canvasLoad 0.3s ease-out;
	}

	/* Hover effects */
	.glass-card:hover {
		transform: translateY(-2px);
	}

	.result-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 0;
		padding-bottom: 0;
	}

	.result-header h3 {
		margin: 0;
		font-size: 1.1rem;
	}

	/* File input enhancements */
	.file-input:hover .file-input-label {
		border-color: var(--accent-primary);
		background: var(--bg-card);
		color: var(--text-primary);
	}

	.file-input.has-file .file-input-label {
		border-color: var(--accent-success);
		background: var(--bg-card);
		color: var(--accent-success);
	}

	.file-input input:disabled + .file-input-label {
		opacity: 0.5;
		cursor: not-allowed;
		background: var(--bg-secondary);
		border-color: var(--border-secondary);
		color: var(--text-muted);
	}

	/* æ¤œç´¢ãƒ‘ãƒãƒ« */
	.search-panel {
		margin-bottom: 1.5rem;
	}

	.search-controls {
		display: flex;
		gap: 1rem;
		align-items: flex-end;
	}

	.search-input-group {
		flex: 1;
		display: flex;
		flex-direction: column;
		gap: 0.5rem;
	}

	.search-input {
		width: 100%;
		padding: 0.5rem 0.75rem;
		background: var(--bg-tertiary);
		border: 1px solid var(--border-primary);
		border-radius: var(--radius-md);
		color: var(--text-primary);
		font-size: 0.875rem;
		font-family: var(--font-mono);
		transition: all 0.2s ease;
	}

	.search-input:focus {
		outline: none;
		border-color: var(--accent-primary);
		box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
	}

	.search-input.invalid {
		border-color: var(--accent-error);
		box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.1);
	}

	.search-mode {
		display: flex;
		gap: 1rem;
	}

	.search-mode-option {
		display: flex;
		align-items: center;
		gap: 0.375rem;
		cursor: pointer;
		font-size: 0.8rem;
		color: var(--text-secondary);
		transition: color 0.2s ease;
	}

	.search-mode-option:hover {
		color: var(--text-primary);
	}

	.search-mode-option input[type="radio"] {
		width: 0.875rem;
		height: 0.875rem;
		appearance: none;
		background: var(--bg-tertiary);
		border: 1px solid var(--border-primary);
		border-radius: 50%;
		position: relative;
		cursor: pointer;
		transition: all 0.2s ease;
	}

	.search-mode-option input[type="radio"]:checked {
		background: var(--accent-primary);
		border-color: var(--accent-primary);
	}

	.search-mode-option input[type="radio"]:checked::after {
		content: '';
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		width: 5px;
		height: 5px;
		background: white;
		border-radius: 50%;
	}

	/* æ¤œç´¢çµæœã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ - å‹•çš„HTMLç”¨ã«ã‚°ãƒ­ãƒ¼ãƒãƒ« */
	:global(.search-highlight) {
		background: #ff6b35;
		color: white;
		padding: 0 2px;
		border-radius: 2px;
		font-weight: bold;
		box-shadow: 0 0 3px rgba(255, 107, 53, 0.5);
	}

	/* ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
	.drag-overlay {
		position: fixed;
		top: 0;
		left: 0;
		width: 100vw;
		height: 100vh;
		background: rgba(59, 130, 246, 0.1);
		backdrop-filter: blur(5px);
		z-index: 9999;
		display: flex;
		align-items: center;
		justify-content: center;
		pointer-events: none;
		transition: opacity 0.2s ease;
	}

	.drag-overlay.hidden {
		opacity: 0;
		pointer-events: none;
		display: none;
	}

	.drag-message {
		background: var(--bg-card);
		border: 2px dashed var(--accent-primary);
		border-radius: var(--radius-lg);
		padding: 3rem;
		text-align: center;
		box-shadow: var(--shadow-xl);
		transform: scale(0.9);
		animation: dragPulse 1.5s ease-in-out infinite;
	}

	.drag-icon {
		font-size: 4rem;
		margin-bottom: 1rem;
		opacity: 0.8;
	}

	.drag-text {
		font-size: 1.5rem;
		font-weight: 600;
		color: var(--accent-primary);
		margin: 0;
	}

	@keyframes dragPulse {
		0%, 100% {
			transform: scale(0.9);
			opacity: 0.8;
		}
		50% {
			transform: scale(1);
			opacity: 1;
		}
	}
</style>
