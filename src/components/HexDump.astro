---

---

<div class="tool-container">
	<div class="tool-header">
		<h1>üìä Hex Dump Tool</h1>
		<p>
			Binary file analysis with hexdump display and visual representation
		</p>
	</div>

	<div class="glass-card tool-controls">
		<div class="file-input">
			<input type="file" id="file-input" accept="*/*" />
			<div class="file-input-label">
				<span>üìÅ Choose Binary File</span>
			</div>
		</div>
		<div class="file-info">
			<div class="file-detail">
				<span class="file-label">File:</span>
				<span id="file-name">No file selected</span>
			</div>
			<div class="file-detail">
				<span class="file-label">Size:</span>
				<span id="file-size">-</span>
			</div>
		</div>
	</div>

	<div class="viewer-grid">
		<div class="glass-card hex-output-container">
			<div class="result-header">
				<h3>Hex Dump Output</h3>
				<div class="format-info">16 bytes per line</div>
			</div>
			<div class="hex-display-wrapper">
				<div id="hex-output" class="hex-output"></div>
				<div class="custom-scrollbar" id="custom-scrollbar">
					<div class="scrollbar-track" id="scrollbar-track">
						<div class="scrollbar-thumb" id="scrollbar-thumb"></div>
					</div>
				</div>
			</div>
			<div class="scroll-info">
				<span id="scroll-position">0%</span>
				<span id="offset-info">Offset: 0x00000000</span>
			</div>
		</div>

		<div class="glass-card canvas-container">
			<div class="result-header">
				<h3>Visual Representation</h3>
				<div class="format-info">256 bytes per line</div>
			</div>
			<div class="canvas-wrapper">
				<canvas id="hex-canvas" width="256" height="400"></canvas>
				<div class="color-legend">
					<div class="legend-item">
						<div
							class="color-sample"
							style="background: #FFFFFF; border: 1px solid var(--border-primary);"
						>
						</div>
						<span>0x00</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #00FFFF;">
						</div>
						<span>0x01-0x1F</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #FF0000;">
						</div>
						<span>0x20-0x7E</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #000000;">
						</div>
						<span>0x80-0xFF</span>
					</div>
				</div>
			</div>
		</div>
	</div>

	<div class="status-bar">
		<span id="status-message">Ready</span>
	</div>
	
	<!-- „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„Éó„Ç™„Éº„Éê„Éº„É¨„Ç§ -->
	<div id="drag-overlay" class="drag-overlay hidden">
		<div class="drag-message">
			<div class="drag-icon">üìÅ</div>
			<div class="drag-text">Drop file here to analyze</div>
		</div>
	</div>
</div>

<script>
	const fileInput = document.getElementById("file-input") as HTMLInputElement;
	const fileName = document.getElementById("file-name") as HTMLSpanElement;
	const fileSize = document.getElementById("file-size") as HTMLSpanElement;
	const hexOutput = document.getElementById("hex-output") as HTMLDivElement;
	const canvas = document.getElementById("hex-canvas") as HTMLCanvasElement;
	const ctx = canvas.getContext("2d", { willReadFrequently: false })!;

	// CanvasÊèèÁîª„ÅÆÊúÄÈÅ©ÂåñË®≠ÂÆö
	ctx.imageSmoothingEnabled = false;
	const customScrollbar = document.getElementById(
		"custom-scrollbar",
	) as HTMLDivElement;
	const scrollbarTrack = document.getElementById(
		"scrollbar-track",
	) as HTMLDivElement;
	const scrollbarThumb = document.getElementById(
		"scrollbar-thumb",
	) as HTMLDivElement;
	const scrollPosition = document.getElementById(
		"scroll-position",
	) as HTMLSpanElement;
	const offsetInfo = document.getElementById(
		"offset-info",
	) as HTMLSpanElement;
	const statusMessage = document.getElementById(
		"status-message",
	) as HTMLSpanElement;
	const dragOverlay = document.getElementById("drag-overlay") as HTMLDivElement;

	let currentFile: File | null = null;
	let totalFileSize = 0;
	let currentOffset = 0;
	let isDragging = false;
	let dragStartY = 0;
	let dragStartOffset = 0;
	let isLoading = false;
	let lastUpdateOffset = -1;
	let dragCounter = 0; // „Éâ„É©„ÉÉ„Ç∞„Ç§„Éô„É≥„Éà„ÅÆÈáçË§áÈò≤Ê≠¢
	
	const BYTES_PER_LINE = 16;
	const CANVAS_BYTES_PER_LINE = 256;
	let LINES_TO_DISPLAY = 50; // ÂãïÁöÑ„Å´Â§âÊõ¥„Åï„Çå„Çã
	let CHUNK_SIZE = LINES_TO_DISPLAY * BYTES_PER_LINE; // Ë°®Á§∫Áî®„ÉÅ„É£„É≥„ÇØ„Çµ„Ç§„Ç∫
	const CANVAS_CHUNK_SIZE = 400 * CANVAS_BYTES_PER_LINE; // CanvasÁî®„ÉÅ„É£„É≥„ÇØ„Çµ„Ç§„Ç∫
	const MIN_THUMB_HEIGHT = 20; // ÊúÄÂ∞è„Çµ„É†„ÅÆÈ´ò„ÅïÔºàpxÔºâ
	const MIN_LINES = 10; // ÊúÄÂ∞èË°®Á§∫Ë°åÊï∞
	const MAX_LINES = 100; // ÊúÄÂ§ßË°®Á§∫Ë°åÊï∞

	function throttle(func: Function, delay: number): Function {
		let timeoutId: number | null | NodeJS.Timeout = null;
		let lastExecTime = 0;
		return function (...args: any[]) {
			const currentTime = Date.now();
			if (currentTime - lastExecTime > delay) {
				func(...args);
				lastExecTime = currentTime;
			} else if (!timeoutId) {
				timeoutId = setTimeout(
					() => {
						func(...args);
						lastExecTime = Date.now();
						timeoutId = null;
					},
					delay - (currentTime - lastExecTime),
				);
			}
		};
	}

	function calculateVisibleLines(): number {
		try {
			// hex-outputË¶ÅÁ¥†„ÅÆÂÆüÈöõ„ÅÆÈ´ò„Åï„ÇíÂèñÂæó
			const containerHeight = hexOutput.clientHeight;
			if (containerHeight === 0) {
				return 35; // „Éá„Éï„Ç©„É´„ÉàÂÄ§
			}

			// „Éë„Éá„Ç£„É≥„Ç∞„ÇíÈô§„ÅÑ„ÅüÂà©Áî®ÂèØËÉΩ„Å™È´ò„Åï
			const padding = 32; // 1rem √ó 2 (top/bottom padding)
			const availableHeight = containerHeight - padding;

			// 1Ë°å„ÅÆÈ´ò„Åï„ÇíË®àÁÆóÔºàfont-size: 0.8rem, line-height: 1.4Ôºâ
			const fontSize = 0.8 * 16; // 0.8rem ‚Üí px
			const lineHeight = fontSize * 1.4; // line-height: 1.4

			// Ë°®Á§∫ÂèØËÉΩ„Å™Ë°åÊï∞„ÇíË®àÁÆó
			const visibleLines = Math.floor(availableHeight / lineHeight);

			// ÊúÄÂ∞èÂÄ§„Å®ÊúÄÂ§ßÂÄ§„ÅÆÁØÑÂõ≤ÂÜÖ„Å´Âà∂Èôê
			return Math.max(MIN_LINES, Math.min(MAX_LINES, visibleLines));
		} catch (error) {
			console.warn("Failed to calculate visible lines:", error);
			return 35; // „Ç®„É©„ÉºÊôÇ„ÅÆ„Éá„Éï„Ç©„É´„ÉàÂÄ§
		}
	}

	function updateChunkSize(): void {
		LINES_TO_DISPLAY = calculateVisibleLines();
		CHUNK_SIZE = LINES_TO_DISPLAY * BYTES_PER_LINE;
		console.log(
			`Updated display lines: ${LINES_TO_DISPLAY}, chunk size: ${CHUNK_SIZE}`,
		);
	}


	function formatFileSize(bytes: number): string {
		if (bytes === 0) return "0 Bytes";
		const k = 1024;
		const sizes = ["Bytes", "KB", "MB", "GB"];
		const i = Math.floor(Math.log(bytes) / Math.log(k));
		return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
	}

	function byteToHex(byte: number): string {
		return byte.toString(16).padStart(2, "0").toUpperCase();
	}

	function byteToChar(byte: number): string {
		return byte >= 0x20 && byte <= 0x7e ? String.fromCharCode(byte) : ".";
	}


	function getByteColorRGB(byte: number): {
		r: number;
		g: number;
		b: number;
	} {
		if (byte === 0x00) return { r: 255, g: 255, b: 255 }; // ÁôΩ
		if (byte >= 0x01 && byte <= 0x1f) return { r: 0, g: 255, b: 255 }; // Ê∞¥Ëâ≤
		if (byte >= 0x20 && byte <= 0x7e) return { r: 255, g: 0, b: 0 }; // Ëµ§
		return { r: 0, g: 0, b: 0 }; // Èªí
	}


	async function loadChunk(
		offset: number,
		size: number,
	): Promise<ArrayBuffer | null> {
		if (!currentFile) return null;

		const start = Math.max(0, offset);
		const end = Math.min(currentFile.size, offset + size);

		if (start >= end) return null;

		try {
			const slice = currentFile.slice(start, end);
			return await slice.arrayBuffer();
		} catch (error) {
			console.error("Error loading chunk:", error);
			return null;
		}
	}

	function updateScrollInfo(percentage: number, offset: number): void {
		scrollPosition.textContent = `${percentage.toFixed(1)}%`;
		offsetInfo.textContent = `Offset: 0x${offset.toString(16).padStart(8, "0").toUpperCase()}`;
	}

	function getMaxOffset(): number {
		if (!totalFileSize || totalFileSize <= CHUNK_SIZE) {
			return 0;
		}
		
		// „Éï„Ç°„Ç§„É´„ÅÆÊúÄÂæå„ÅÆ„Éê„Ç§„Éà„ÅåÂê´„Åæ„Çå„ÇãË°å„ÅÆÈñãÂßã„Ç™„Éï„Çª„ÉÉ„Éà
		const lastByteOffset = totalFileSize - 1;
		const lastLineStartOffset = Math.floor(lastByteOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
		
		return Math.max(0, lastLineStartOffset);
	}

	function calculateScrollbarDimensions(): {
		thumbHeight: number;
		thumbPosition: number;
		visible: boolean;
	} {
		if (!totalFileSize || totalFileSize <= CHUNK_SIZE) {
			return { thumbHeight: 0, thumbPosition: 0, visible: false };
		}

		const trackHeight = scrollbarTrack.clientHeight;
		const visibleRatio = CHUNK_SIZE / totalFileSize;
		const thumbHeight = Math.max(
			MIN_THUMB_HEIGHT,
			trackHeight * visibleRatio,
		);

		const maxOffset = getMaxOffset();
		const scrollProgress = maxOffset > 0 ? currentOffset / maxOffset : 0;
		const maxThumbPosition = trackHeight - thumbHeight;
		const thumbPosition = scrollProgress * maxThumbPosition;

		return { thumbHeight, thumbPosition, visible: true };
	}

	function updateScrollbarAppearance(): void {
		const { thumbHeight, thumbPosition, visible } =
			calculateScrollbarDimensions();

		if (visible) {
			customScrollbar.classList.remove("hidden");
			scrollbarThumb.style.height = `${thumbHeight}px`;
			scrollbarThumb.style.top = `${thumbPosition}px`;
		} else {
			customScrollbar.classList.add("hidden");
		}
	}

	function generateHexDump(buffer: ArrayBuffer, fileOffset: number): string {
		const bytes = new Uint8Array(buffer);
		let output = "";

		for (let i = 0; i < bytes.length; i += BYTES_PER_LINE) {
			const actualOffset = fileOffset + i;
			const lineOffset = actualOffset
				.toString(16)
				.padStart(8, "0")
				.toUpperCase();
			let hexPart = "";
			let textPart = "";

			for (let j = 0; j < BYTES_PER_LINE; j++) {
				const byteIndex = i + j;
				
				if (byteIndex < bytes.length) {
					const byte = bytes[byteIndex];
					hexPart += byteToHex(byte) + " ";
					textPart += byteToChar(byte);
				} else {
					hexPart += "   ";
					textPart += " ";
				}
			}

			output += `${lineOffset}: ${hexPart} |${textPart}|\n`;
		}

		return output;
	}

	function drawCanvas(buffer: ArrayBuffer): void {
		const bytes = new Uint8Array(buffer);
		const canvasWidth = canvas.width;
		const canvasHeight = canvas.height;

		// ImageData„Çí‰ΩøÁî®„Åó„ÅüÊúÄÈÅ©Âåñ„Åï„Çå„ÅüÊèèÁîª
		const imageData = ctx.createImageData(canvasWidth, canvasHeight);
		const data = imageData.data;

		// ËÉåÊôØ„ÇíÈªí„ÅßÂàùÊúüÂåñÔºà„Éá„Éº„Çø„Åå„Å™„ÅÑÈÉ®ÂàÜÔºâ
		for (let i = 0; i < data.length; i += 4) {
			data[i] = 0; // Red
			data[i + 1] = 0; // Green
			data[i + 2] = 0; // Blue
			data[i + 3] = 255; // Alpha
		}

		// „Éê„Ç§„Éà„Éá„Éº„Çø„ÇíËâ≤ÊÉÖÂ†±„Å´Â§âÊèõ
		const totalPixels = canvasWidth * canvasHeight;
		const bytesToProcess = Math.min(bytes.length, totalPixels);

		for (let i = 0; i < bytesToProcess; i++) {
			const byte = bytes[i];
			const color = getByteColorRGB(byte);
			const pixelIndex = i * 4;

			data[pixelIndex] = color.r; // Red
			data[pixelIndex + 1] = color.g; // Green
			data[pixelIndex + 2] = color.b; // Blue
			data[pixelIndex + 3] = 255; // Alpha
		}

		// ‰∏ÄÂ∫¶„Å´ÂÖ®‰Ωì„ÇíÊèèÁîª
		ctx.putImageData(imageData, 0, 0);
	}

	function setLoadingState(
		loading: boolean,
		message: string = "Ready",
	): void {
		isLoading = loading;
		if (loading) {
			statusMessage.textContent = message;
			statusMessage.classList.add("loading");
		} else {
			statusMessage.textContent = "Ready";
			statusMessage.classList.remove("loading");
		}
	}

	async function updateDisplay(): Promise<void> {
		if (!currentFile || isLoading) return;

		// „Ç≠„É£„ÉÉ„Ç∑„É•„ÉÅ„Çß„ÉÉ„ÇØÔºöÂêå„Åò„Ç™„Éï„Çª„ÉÉ„Éà„ÅÆÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
		if (lastUpdateOffset === currentOffset) return;

		setLoadingState(true, "Loading file data...");
		lastUpdateOffset = currentOffset;

		try {
			// HexdumpÁî®„ÅÆ„ÉÅ„É£„É≥„ÇØ„ÇíË™≠„ÅøËæº„ÅøÔºà„Éï„Ç°„Ç§„É´ÁµÇÁ´Ø„ÇíËÄÉÊÖÆÔºâ
			const remainingBytes = totalFileSize - currentOffset;
			const readSize = Math.min(CHUNK_SIZE, remainingBytes);
			const hexBuffer = await loadChunk(currentOffset, readSize);
			if (hexBuffer) {
				const hexDump = generateHexDump(hexBuffer, currentOffset);
				hexOutput.innerHTML = hexDump; // HTML„Å®„Åó„Å¶Ë°®Á§∫
			}

			// CanvasÁî®„ÅÆ„ÉÅ„É£„É≥„ÇØ„ÇíË™≠„ÅøËæº„ÅøÔºà„Çà„ÇäÂ§ß„Åç„Å™„ÉÅ„É£„É≥„ÇØÔºâ
			setLoadingState(true, "Rendering canvas...");
			const canvasBuffer = await loadChunk(
				currentOffset,
				CANVAS_CHUNK_SIZE,
			);
			if (canvasBuffer) {
				drawCanvas(canvasBuffer);
				canvas.classList.add("loaded");
			}

			// „Çπ„ÇØ„É≠„Éº„É´ÊÉÖÂ†±„ÇíÊõ¥Êñ∞
			const maxOffset = getMaxOffset();
			const percentage = maxOffset > 0 ? (currentOffset / maxOffset) * 100 : 0;
			updateScrollInfo(Math.min(percentage, 100), currentOffset);
			updateScrollbarAppearance();
		} catch (error) {
			console.error("Error updating display:", error);
			setLoadingState(false, "Error loading file");
		} finally {
			setLoadingState(false);
		}
	}

	function handleThumbMouseDown(event: MouseEvent): void {
		if (!currentFile) return;

		isDragging = true;
		dragStartY = event.clientY;
		dragStartOffset = currentOffset;

		scrollbarThumb.classList.add("dragging");
		document.addEventListener("mousemove", handleThumbMouseMove);
		document.addEventListener("mouseup", handleThumbMouseUp);

		event.preventDefault();
	}

	const throttledUpdateDisplay = throttle(updateDisplay, 16); // 60FPSÁõ∏ÂΩì

	function handleThumbMouseMove(event: MouseEvent): void {
		if (!isDragging || !currentFile) return;

		const deltaY = event.clientY - dragStartY;
		const trackHeight = scrollbarTrack.clientHeight;
		const { thumbHeight } = calculateScrollbarDimensions();
		const maxThumbPosition = trackHeight - thumbHeight;

		if (maxThumbPosition <= 0) return;

		const scrollRatio = deltaY / maxThumbPosition;
		const maxOffset = getMaxOffset();
		const newOffset = dragStartOffset + scrollRatio * maxOffset;

		currentOffset = Math.max(0, Math.min(maxOffset, newOffset));
		currentOffset =
			Math.floor(currentOffset / BYTES_PER_LINE) * BYTES_PER_LINE;

		throttledUpdateDisplay();
	}

	function handleThumbMouseUp(): void {
		if (!isDragging) return;

		isDragging = false;
		scrollbarThumb.classList.remove("dragging");
		document.removeEventListener("mousemove", handleThumbMouseMove);
		document.removeEventListener("mouseup", handleThumbMouseUp);
	}

	function handleTrackClick(event: MouseEvent): void {
		if (!currentFile || event.target === scrollbarThumb) return;

		const rect = scrollbarTrack.getBoundingClientRect();
		const clickY = event.clientY - rect.top;
		const trackHeight = scrollbarTrack.clientHeight;
		const { thumbHeight } = calculateScrollbarDimensions();
		const maxThumbPosition = trackHeight - thumbHeight;

		if (maxThumbPosition <= 0) return;

		const scrollRatio = Math.max(0, Math.min(1, clickY / trackHeight));
		const maxOffset = getMaxOffset();
		currentOffset =
			Math.floor((scrollRatio * maxOffset) / BYTES_PER_LINE) *
			BYTES_PER_LINE;

		updateDisplay(); // „ÇØ„É™„ÉÉ„ÇØÊôÇ„ÅØÂç≥Â∫ß„Å´Êõ¥Êñ∞
	}

	async function handleFileChange(event: Event): Promise<void> {
		const target = event.target as HTMLInputElement;
		const file = target.files?.[0];

		if (!file) {
			currentFile = null;
			totalFileSize = 0;
			currentOffset = 0;
			lastUpdateOffset = -1; // „Ç≠„É£„ÉÉ„Ç∑„É•„É™„Çª„ÉÉ„Éà
			customScrollbar.classList.add("hidden");
			hexOutput.textContent = "";
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			updateScrollInfo(0, 0);
			statusMessage.textContent = "Ready";
			statusMessage.classList.remove("loading");
			return;
		}

		currentFile = file;
		totalFileSize = file.size;
		currentOffset = 0;
		lastUpdateOffset = -1; // „Ç≠„É£„ÉÉ„Ç∑„É•„É™„Çª„ÉÉ„Éà

		fileName.textContent = file.name;
		fileSize.textContent = formatFileSize(file.size);

		// Ë°®Á§∫Ë°åÊï∞„ÇíÂãïÁöÑ„Å´Ë®àÁÆó„Åó„Å¶Êõ¥Êñ∞
		updateChunkSize();

		try {
			await updateDisplay();
		} catch (error) {
			console.error("Error reading file:", error);
			statusMessage.textContent = "Error loading file";
			statusMessage.classList.remove("loading");
		}
	}

	fileInput.addEventListener("change", handleFileChange);

	// „Éõ„Ç§„Éº„É´„Çπ„ÇØ„É≠„Éº„É´„Éè„É≥„Éâ„É©„Éº
	function handleWheelScroll(event: WheelEvent): void {
		if (!currentFile) return;

		event.preventDefault();

		const scrollLines = 3; // ‰∏ÄÂ∫¶„Å´„Çπ„ÇØ„É≠„Éº„É´„Åô„ÇãË°åÊï∞
		const scrollAmount = scrollLines * BYTES_PER_LINE;
		const maxOffset = getMaxOffset();

		if (event.deltaY > 0) {
			// ‰∏ã„Çπ„ÇØ„É≠„Éº„É´
			currentOffset = Math.min(maxOffset, currentOffset + scrollAmount);
		} else {
			// ‰∏ä„Çπ„ÇØ„É≠„Éº„É´
			currentOffset = Math.max(0, currentOffset - scrollAmount);
		}

		currentOffset =
			Math.floor(currentOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
		throttledUpdateDisplay();
	}

	// „Ç≠„Éº„Éú„Éº„ÉâÊìç‰Ωú„Éè„É≥„Éâ„É©„Éº
	function handleKeyDown(event: KeyboardEvent): void {
		if (!currentFile) return;

		const maxOffset = getMaxOffset();
		const pageSize = LINES_TO_DISPLAY * BYTES_PER_LINE;

		let handled = false;

		switch (event.key) {
			case "ArrowUp":
				currentOffset = Math.max(0, currentOffset - BYTES_PER_LINE);
				handled = true;
				break;
			case "ArrowDown":
				currentOffset = Math.min(
					maxOffset,
					currentOffset + BYTES_PER_LINE,
				);
				handled = true;
				break;
			case "PageUp":
				currentOffset = Math.max(0, currentOffset - pageSize);
				handled = true;
				break;
			case "PageDown":
				currentOffset = Math.min(maxOffset, currentOffset + pageSize);
				handled = true;
				break;
			case "Home":
				currentOffset = 0;
				handled = true;
				break;
			case "End":
				currentOffset = maxOffset;
				handled = true;
				break;
		}

		if (handled) {
			event.preventDefault();
			currentOffset =
				Math.floor(currentOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
			throttledUpdateDisplay();
		}
	}

	// „Çπ„ÇØ„É≠„Éº„É´„Éê„Éº„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
	scrollbarThumb.addEventListener("mousedown", handleThumbMouseDown);
	scrollbarTrack.addEventListener("click", handleTrackClick);

	// hex-output„Ç®„É™„Ç¢„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
	hexOutput.addEventListener("wheel", handleWheelScroll, { passive: false });

	// „Ç≠„Éº„Éú„Éº„Éâ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºÔºà„Éï„Ç©„Éº„Ç´„Çπ„ÅåÂøÖË¶ÅÔºâ
	hexOutput.setAttribute("tabindex", "0");
	hexOutput.addEventListener("keydown", handleKeyDown);

	// ÂàùÊúüÂåñÊôÇ„Å´ÂãïÁöÑË°åÊï∞„ÇíË®àÁÆó
	document.addEventListener("DOMContentLoaded", () => {
		// Â∞ë„ÅóÈÅÖÂª∂„Åï„Åõ„Å¶Ë¶ÅÁ¥†„ÅÆ„É¨„É≥„ÉÄ„É™„É≥„Ç∞„ÇíÂæÖ„Å§
		setTimeout(() => {
			updateChunkSize();
		}, 100);
	});

	// „Ç¶„Ç£„É≥„Éâ„Ç¶„É™„Çµ„Ç§„Ç∫ÊôÇ„ÅÆÂÜçË®àÁÆóÔºàthrottledÔºâ
	const throttledResize = throttle(() => {
		if (currentFile) {
			const oldChunkSize = CHUNK_SIZE;
			updateChunkSize();
			
			// „ÉÅ„É£„É≥„ÇØ„Çµ„Ç§„Ç∫„ÅåÂ§âÊõ¥„Åï„Çå„ÅüÂ†¥Âêà„ÅØÂÜçÊèèÁîª
			if (CHUNK_SIZE !== oldChunkSize) {
				lastUpdateOffset = -1; // „Ç≠„É£„ÉÉ„Ç∑„É•„É™„Çª„ÉÉ„Éà
				updateDisplay();
			}
		}
	}, 250); // „É™„Çµ„Ç§„Ç∫„ÅØ250msÈñìÈöî„ÅßÂà∂Èôê

	window.addEventListener("resize", throttledResize as EventListener);

	// OffsetÂÄ§„Ç∏„É£„É≥„ÉóÊ©üËÉΩ
	function handleOffsetClick(): void {
		if (!currentFile) return;

		const input = prompt(
			"Jump to offset (hexadecimal, e.g., 1000 or 0x1000):",
			"0x" + currentOffset.toString(16).toUpperCase(),
		);

		if (input === null) return; // „Ç≠„É£„É≥„Çª„É´

		let targetOffset: number;
		try {
			// 16ÈÄ≤Êï∞„Å®„Åó„Å¶Ëß£ÊûêÔºà0x„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÅÆÊúâÁÑ°„ÇíÂïè„Çè„Å™„ÅÑÔºâ
			const cleanInput = input.trim().toLowerCase();
			if (cleanInput.startsWith("0x")) {
				targetOffset = parseInt(cleanInput, 16);
			} else {
				targetOffset = parseInt(cleanInput, 16);
			}

			if (isNaN(targetOffset) || targetOffset < 0) {
				alert("Invalid offset value. Please enter a valid hexadecimal number.");
				return;
			}

			// „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫ÂÜÖ„Å´Âà∂Èôê
			const maxOffset = getMaxOffset();
			targetOffset = Math.min(targetOffset, maxOffset);

			// Ë°åÂ¢ÉÁïå„Å´ÊèÉ„Åà„Çã
			targetOffset = Math.floor(targetOffset / BYTES_PER_LINE) * BYTES_PER_LINE;

			currentOffset = targetOffset;
			lastUpdateOffset = -1; // „Ç≠„É£„ÉÉ„Ç∑„É•„É™„Çª„ÉÉ„Éà
			updateDisplay();
		} catch (error) {
			alert("Invalid offset value. Please enter a valid hexadecimal number.");
		}
	}

	// OffsetÊÉÖÂ†±„Çí„ÇØ„É™„ÉÉ„ÇØÂèØËÉΩ„Å´„Åô„Çã
	offsetInfo.addEventListener("click", handleOffsetClick);

	// Canvas‰∏ä„Åß„ÅÆ„ÇØ„É™„ÉÉ„ÇØ„Ç∏„É£„É≥„ÉóÊ©üËÉΩ
	function handleCanvasClick(event: MouseEvent): void {
		if (!currentFile) return;

		const rect = canvas.getBoundingClientRect();
		const x = event.clientX - rect.left;
		const y = event.clientY - rect.top;

		// CanvasÂÜÖ„ÅÆÂ∫ßÊ®ô„Çí„Éî„ÇØ„Çª„É´Â∫ßÊ®ô„Å´Â§âÊèõ
		const canvasX = Math.floor(x);
		const canvasY = Math.floor(y);

		// CanvasÊèèÁîªÈ†òÂüüÂÜÖ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
		if (canvasX < 0 || canvasX >= canvas.width || canvasY < 0 || canvasY >= canvas.height) {
			return;
		}

		// „ÇØ„É™„ÉÉ„ÇØ‰ΩçÁΩÆ„ÅÆ„Éê„Ç§„Éà„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíË®àÁÆó
		const bytesPerCanvasLine = CANVAS_BYTES_PER_LINE;
		const byteIndex = canvasY * bytesPerCanvasLine + canvasX;

		// ÁèæÂú®„ÅÆCanvasË°®Á§∫„Ç™„Éï„Çª„ÉÉ„Éà„ÇíËÄÉÊÖÆ„Åó„Å¶„Éï„Ç°„Ç§„É´ÂÜÖ„Ç™„Éï„Çª„ÉÉ„Éà„ÇíË®àÁÆó
		const fileByteOffset = currentOffset + byteIndex;

		// „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫ÂÜÖ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
		if (fileByteOffset >= totalFileSize) {
			return;
		}

		// 16„Éê„Ç§„ÉàÂ¢ÉÁïå„Å´‰∏∏„ÇÅ„Åü„Ç™„Éï„Çª„ÉÉ„Éà„ÇíË®àÁÆó
		const targetOffset = Math.floor(fileByteOffset / BYTES_PER_LINE) * BYTES_PER_LINE;

		// ÊúÄÂ§ß„Ç™„Éï„Çª„ÉÉ„ÉàÂÜÖ„Å´Âà∂Èôê
		const maxOffset = getMaxOffset();
		const clampedOffset = Math.min(targetOffset, maxOffset);

		// „Ç∏„É£„É≥„ÉóÂÆüË°å
		if (clampedOffset !== currentOffset) {
			currentOffset = clampedOffset;
			lastUpdateOffset = -1; // „Ç≠„É£„ÉÉ„Ç∑„É•„É™„Çª„ÉÉ„Éà
			updateDisplay();
		}
	}

	// Canvas„Å´„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíËøΩÂä†
	canvas.addEventListener("click", handleCanvasClick);

	// „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„ÉóÊ©üËÉΩ
	function handleDragEnter(event: DragEvent): void {
		event.preventDefault();
		dragCounter++;
		if (dragCounter === 1) {
			dragOverlay.classList.remove("hidden");
		}
	}

	function handleDragOver(event: DragEvent): void {
		event.preventDefault();
		event.dataTransfer!.dropEffect = "copy";
	}

	function handleDragLeave(event: DragEvent): void {
		event.preventDefault();
		dragCounter--;
		if (dragCounter === 0) {
			dragOverlay.classList.add("hidden");
		}
	}

	function handleDrop(event: DragEvent): void {
		event.preventDefault();
		dragCounter = 0;
		dragOverlay.classList.add("hidden");

		const files = event.dataTransfer?.files;
		if (files && files.length > 0) {
			const file = files[0];
			// Êó¢Â≠ò„ÅÆhandleFileChangeÈñ¢Êï∞„ÅÆ„É≠„Ç∏„ÉÉ„ÇØ„ÇíÊµÅÁî®
			processDroppedFile(file);
		}
	}

	async function processDroppedFile(file: File): Promise<void> {
		currentFile = file;
		totalFileSize = file.size;
		currentOffset = 0;
		lastUpdateOffset = -1; // „Ç≠„É£„ÉÉ„Ç∑„É•„É™„Çª„ÉÉ„Éà

		fileName.textContent = file.name;
		fileSize.textContent = formatFileSize(file.size);

		// Ë°®Á§∫Ë°åÊï∞„ÇíÂãïÁöÑ„Å´Ë®àÁÆó„Åó„Å¶Êõ¥Êñ∞
		updateChunkSize();

		try {
			await updateDisplay();
		} catch (error) {
			console.error("Error reading file:", error);
			statusMessage.textContent = "Error loading file";
			statusMessage.classList.remove("loading");
		}
	}

	// „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„Éó„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„Çídocument„Å´ËøΩÂä†
	document.addEventListener("dragenter", handleDragEnter);
	document.addEventListener("dragover", handleDragOver);
	document.addEventListener("dragleave", handleDragLeave);
	document.addEventListener("drop", handleDrop);

</script>

<style>
	.file-info {
		display: flex;
		gap: 2rem;
		margin-top: 1rem;
	}

	.file-detail {
		display: flex;
		gap: 0.5rem;
		align-items: center;
	}

	.file-label {
		font-weight: 500;
		color: var(--text-secondary);
		min-width: 3rem;
	}

	#file-name {
		font-weight: 500;
		color: var(--text-primary);
		font-family: var(--font-mono);
		font-size: 0.875rem;
	}

	#file-size {
		color: var(--text-accent);
		font-family: var(--font-mono);
		font-size: 0.875rem;
	}

	.viewer-grid {
		display: grid;
		grid-template-columns: 1fr 300px;
		gap: 1.5rem;
		margin-top: 1.5rem;
	}

	.hex-output-container {
		max-height: 800px;
		display: flex;
		flex-direction: column;
	}

	.hex-display-wrapper {
		flex: 1;
		display: flex;
		margin-top: 1rem;
		gap: 0; /* „Çπ„ÇØ„É≠„Éº„É´„Éê„Éº„ÇíÈöôÈñì„Å™„ÅèÈÖçÁΩÆ */
	}

	.hex-output {
		flex: 1;
		font-family: var(--font-mono);
		font-size: 0.8rem;
		line-height: 1.4;
		color: var(--text-primary);
		white-space: pre;
		padding: 1rem;
		background: var(--bg-tertiary);
		border-radius: var(--radius-md);
		border: 1px solid var(--border-primary);
		max-height: 600px;
		overflow: hidden; /* ÂÜÖËîµ„Çπ„ÇØ„É≠„Éº„É´„ÇíÁÑ°ÂäπÂåñ */
		border-top-right-radius: 0;
		border-bottom-right-radius: 0;
		border-right: none;
	}

	.custom-scrollbar {
		width: 12px;
		background: var(--bg-tertiary);
		border: 1px solid var(--border-primary);
		border-left: none;
		border-top-right-radius: var(--radius-md);
		border-bottom-right-radius: var(--radius-md);
		position: relative;
		max-height: 600px;
	}

	.custom-scrollbar.hidden {
		display: none;
	}

	.scrollbar-track {
		position: absolute;
		top: 2px;
		left: 2px;
		right: 2px;
		bottom: 2px;
		background: var(--bg-secondary);
		border-radius: 4px;
		cursor: pointer;
	}

	.scrollbar-thumb {
		position: absolute;
		left: 0;
		right: 0;
		background: var(--text-muted);
		border-radius: 4px;
		cursor: pointer;
		transition: background-color 0.2s ease;
		min-height: 20px;
		opacity: 0.8;
	}

	.scrollbar-thumb:hover {
		background: var(--text-secondary);
		opacity: 1;
	}

	.scrollbar-thumb.dragging {
		background: var(--accent-primary);
		opacity: 1;
	}

	.scroll-info {
		display: flex;
		justify-content: space-between;
		margin-top: 0.5rem;
		font-size: 0.75rem;
		color: var(--text-secondary);
		font-family: var(--font-mono);
	}

	#offset-info {
		cursor: pointer;
		padding: 0.25rem 0.5rem;
		border-radius: var(--radius-sm);
		transition: all 0.2s ease;
	}

	#offset-info:hover {
		background: var(--bg-card);
		color: var(--accent-primary);
		transform: translateY(-1px);
	}


	.canvas-container {
		display: flex;
		flex-direction: column;
		max-height: 800px;
	}

	.canvas-wrapper {
		flex: 1;
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 1rem;
		margin-top: 1rem;
	}

	#hex-canvas {
		border: 1px solid var(--border-primary);
		image-rendering: pixelated;
		background: var(--bg-tertiary);
		box-shadow: var(--shadow-md);
		transition: box-shadow 0.2s ease;
		cursor: pointer;
	}

	#hex-canvas:hover {
		box-shadow: var(--shadow-lg), 0 0 10px rgba(59, 130, 246, 0.3);
		border-color: var(--accent-primary);
	}

	.color-legend {
		display: grid;
		grid-template-columns: repeat(2, 1fr);
		gap: 0.5rem;
		width: 100%;
		max-width: 256px;
	}

	.legend-item {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		font-size: 0.75rem;
		color: var(--text-secondary);
	}

	.color-sample {
		width: 12px;
		height: 12px;
		border-radius: 2px;
		flex-shrink: 0;
	}

	.format-info {
		font-size: 0.75rem;
		color: var(--text-muted);
		font-family: var(--font-mono);
	}

	/* Status bar */
	.status-bar {
		margin-top: 1rem;
		padding: 0.5rem 1rem;
		background: var(--bg-tertiary);
		border: 1px solid var(--border-primary);
		border-radius: var(--radius-md);
		display: flex;
		align-items: center;
		min-height: 2rem;
	}

	#status-message {
		font-size: 0.875rem;
		color: var(--text-secondary);
		font-family: var(--font-mono);
	}

	#status-message.loading {
		color: var(--accent-primary);
		position: relative;
	}

	#status-message.loading::after {
		content: "";
		width: 12px;
		height: 12px;
		border: 2px solid var(--border-primary);
		border-top: 2px solid var(--accent-primary);
		border-radius: 50%;
		animation: spin 1s linear infinite;
		margin-left: 0.5rem;
		display: inline-block;
	}

	@keyframes spin {
		0% {
			transform: rotate(0deg);
		}
		100% {
			transform: rotate(360deg);
		}
	}

	/* Empty state */
	.hex-output:empty::before {
		content: "Select a file to view its hex dump...";
		color: var(--text-muted);
		font-style: italic;
		display: flex;
		align-items: center;
		justify-content: center;
		height: 100%;
	}

	/* Animation for canvas */
	@keyframes canvasLoad {
		0% {
			opacity: 0;
			transform: scale(0.9);
		}
		100% {
			opacity: 1;
			transform: scale(1);
		}
	}

	#hex-canvas.loaded {
		animation: canvasLoad 0.3s ease-out;
	}

	/* Hover effects */
	.glass-card:hover {
		transform: translateY(-2px);
	}

	.result-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 0;
		padding-bottom: 0;
	}

	.result-header h3 {
		margin: 0;
		font-size: 1.1rem;
	}

	/* File input enhancements */
	.file-input:hover .file-input-label {
		border-color: var(--accent-primary);
		background: var(--bg-card);
		color: var(--text-primary);
	}

	.file-input.has-file .file-input-label {
		border-color: var(--accent-success);
		background: var(--bg-card);
		color: var(--accent-success);
	}

	/* „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„Éó„Ç™„Éº„Éê„Éº„É¨„Ç§ */
	.drag-overlay {
		position: fixed;
		top: 0;
		left: 0;
		width: 100vw;
		height: 100vh;
		background: rgba(59, 130, 246, 0.1);
		backdrop-filter: blur(5px);
		z-index: 9999;
		display: flex;
		align-items: center;
		justify-content: center;
		pointer-events: none;
		transition: opacity 0.2s ease;
	}

	.drag-overlay.hidden {
		opacity: 0;
		pointer-events: none;
		display: none;
	}

	.drag-message {
		background: var(--bg-card);
		border: 2px dashed var(--accent-primary);
		border-radius: var(--radius-lg);
		padding: 3rem;
		text-align: center;
		box-shadow: var(--shadow-xl);
		transform: scale(0.9);
		animation: dragPulse 1.5s ease-in-out infinite;
	}

	.drag-icon {
		font-size: 4rem;
		margin-bottom: 1rem;
		opacity: 0.8;
	}

	.drag-text {
		font-size: 1.5rem;
		font-weight: 600;
		color: var(--accent-primary);
		margin: 0;
	}

	@keyframes dragPulse {
		0%, 100% {
			transform: scale(0.9);
			opacity: 0.8;
		}
		50% {
			transform: scale(1);
			opacity: 1;
		}
	}
</style>
