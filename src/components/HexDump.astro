---

---

<div class="tool-container">
	<div class="tool-header">
		<h1>üìä Hex Dump Tool</h1>
		<p>
			Binary file analysis with hexdump display and visual representation
		</p>
	</div>

	<div class="glass-card tool-controls">
		<div class="file-input">
			<input type="file" id="file-input" accept="*/*" />
			<div class="file-input-label">
				<span>üìÅ Choose Binary File</span>
			</div>
		</div>
		<div class="file-info">
			<div class="file-detail">
				<span class="file-label">File:</span>
				<span id="file-name">No file selected</span>
			</div>
			<div class="file-detail">
				<span class="file-label">Size:</span>
				<span id="file-size">-</span>
			</div>
		</div>
	</div>

	<div class="glass-card search-panel">
		<div class="search-controls">
			<div class="search-input-group">
				<input type="text" id="search-input" class="search-input" placeholder="Enter search pattern..." />
				<div class="search-mode">
					<label class="search-mode-option">
						<input type="radio" name="search-mode" value="ascii" checked />
						<span>ASCII</span>
					</label>
					<label class="search-mode-option">
						<input type="radio" name="search-mode" value="hex" />
						<span>Hex</span>
					</label>
				</div>
			</div>
			<button id="search-toggle-btn" class="btn btn-primary" disabled>
				<span id="search-btn-text">Search</span>
			</button>
		</div>
	</div>

	<div class="viewer-grid">
		<div class="glass-card hex-output-container">
			<div class="result-header">
				<h3>Hex Dump Output</h3>
				<div class="format-info">16 bytes per line</div>
			</div>
			<div class="hex-display-wrapper">
				<div id="hex-output" class="hex-output"></div>
				<div class="custom-scrollbar" id="custom-scrollbar">
					<div class="scrollbar-track" id="scrollbar-track">
						<div class="scrollbar-thumb" id="scrollbar-thumb"></div>
					</div>
				</div>
			</div>
			<div class="scroll-info">
				<span id="scroll-position">0%</span>
				<span id="offset-info">Offset: 0x00000000</span>
			</div>
		</div>

		<div class="glass-card canvas-container">
			<div class="result-header">
				<h3>Visual Representation</h3>
				<div class="format-info">256 bytes per line</div>
			</div>
			<div class="canvas-wrapper">
				<canvas id="hex-canvas" width="256" height="400"></canvas>
				<div class="color-legend">
					<div class="legend-item">
						<div
							class="color-sample"
							style="background: #FFFFFF; border: 1px solid var(--border-primary);"
						>
						</div>
						<span>0x00</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #00FFFF;">
						</div>
						<span>0x01-0x1F</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #FF0000;">
						</div>
						<span>0x20-0x7E</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #000000;">
						</div>
						<span>0x80-0xFF</span>
					</div>
				</div>
			</div>
		</div>
	</div>

	<div class="status-bar">
		<span id="status-message">Ready</span>
	</div>
	
	<!-- „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„Éó„Ç™„Éº„Éê„Éº„É¨„Ç§ -->
	<div id="drag-overlay" class="drag-overlay hidden">
		<div class="drag-message">
			<div class="drag-icon">üìÅ</div>
			<div class="drag-text">Drop file here to analyze</div>
		</div>
	</div>
</div>

<script>
	const fileInput = document.getElementById("file-input") as HTMLInputElement;
	const fileName = document.getElementById("file-name") as HTMLSpanElement;
	const fileSize = document.getElementById("file-size") as HTMLSpanElement;
	const hexOutput = document.getElementById("hex-output") as HTMLDivElement;
	const canvas = document.getElementById("hex-canvas") as HTMLCanvasElement;
	const ctx = canvas.getContext("2d", { willReadFrequently: false })!;

	// CanvasÊèèÁîª„ÅÆÊúÄÈÅ©ÂåñË®≠ÂÆö
	ctx.imageSmoothingEnabled = false;
	const customScrollbar = document.getElementById(
		"custom-scrollbar",
	) as HTMLDivElement;
	const scrollbarTrack = document.getElementById(
		"scrollbar-track",
	) as HTMLDivElement;
	const scrollbarThumb = document.getElementById(
		"scrollbar-thumb",
	) as HTMLDivElement;
	const scrollPosition = document.getElementById(
		"scroll-position",
	) as HTMLSpanElement;
	const offsetInfo = document.getElementById(
		"offset-info",
	) as HTMLSpanElement;
	const statusMessage = document.getElementById(
		"status-message",
	) as HTMLSpanElement;
	const dragOverlay = document.getElementById("drag-overlay") as HTMLDivElement;
	
	// Ê§úÁ¥¢Èñ¢ÈÄ£„ÅÆË¶ÅÁ¥†
	const searchInput = document.getElementById("search-input") as HTMLInputElement;
	const searchToggleBtn = document.getElementById("search-toggle-btn") as HTMLButtonElement;
	const searchBtnText = document.getElementById("search-btn-text") as HTMLSpanElement;
	const searchModeInputs = document.querySelectorAll('input[name="search-mode"]') as NodeListOf<HTMLInputElement>;

	let currentFile: File | null = null;
	let totalFileSize = 0;
	let currentOffset = 0;
	let isDragging = false;
	let dragStartY = 0;
	let dragStartOffset = 0;
	let isLoading = false;
	let lastUpdateOffset = -1;
	let dragCounter = 0; // „Éâ„É©„ÉÉ„Ç∞„Ç§„Éô„É≥„Éà„ÅÆÈáçË§áÈò≤Ê≠¢
	
	// Ê§úÁ¥¢Èñ¢ÈÄ£„ÅÆÁä∂ÊÖãÂ§âÊï∞
	let isSearching = false;
	let searchAbortController: AbortController | null = null;
	let searchResultOffset = -1;
	let searchPattern: Uint8Array | null = null;
	
	const BYTES_PER_LINE = 16;
	const CANVAS_BYTES_PER_LINE = 256;
	let LINES_TO_DISPLAY = 50; // ÂãïÁöÑ„Å´Â§âÊõ¥„Åï„Çå„Çã
	let CHUNK_SIZE = LINES_TO_DISPLAY * BYTES_PER_LINE; // Ë°®Á§∫Áî®„ÉÅ„É£„É≥„ÇØ„Çµ„Ç§„Ç∫
	const CANVAS_CHUNK_SIZE = 400 * CANVAS_BYTES_PER_LINE; // CanvasÁî®„ÉÅ„É£„É≥„ÇØ„Çµ„Ç§„Ç∫
	const MIN_THUMB_HEIGHT = 20; // ÊúÄÂ∞è„Çµ„É†„ÅÆÈ´ò„ÅïÔºàpxÔºâ
	const MIN_LINES = 10; // ÊúÄÂ∞èË°®Á§∫Ë°åÊï∞
	const MAX_LINES = 100; // ÊúÄÂ§ßË°®Á§∫Ë°åÊï∞

	function throttle(func: Function, delay: number): Function {
		let timeoutId: number | null | NodeJS.Timeout = null;
		let lastExecTime = 0;
		return function (...args: any[]) {
			const currentTime = Date.now();
			if (currentTime - lastExecTime > delay) {
				func(...args);
				lastExecTime = currentTime;
			} else if (!timeoutId) {
				timeoutId = setTimeout(
					() => {
						func(...args);
						lastExecTime = Date.now();
						timeoutId = null;
					},
					delay - (currentTime - lastExecTime),
				);
			}
		};
	}

	function calculateVisibleLines(): number {
		try {
			// hex-display-wrapperË¶ÅÁ¥†„ÅÆÂÆüÈöõ„ÅÆÈ´ò„Åï„ÇíÂèñÂæó
			const wrapper = document.querySelector('.hex-display-wrapper') as HTMLElement;
			if (!wrapper) {
				return 35; // „Éá„Éï„Ç©„É´„ÉàÂÄ§
			}

			const wrapperHeight = wrapper.clientHeight;
			if (wrapperHeight === 0) {
				return 35; // „Éá„Éï„Ç©„É´„ÉàÂÄ§
			}

			// hex-outputË¶ÅÁ¥†„ÅÆ„Éë„Éá„Ç£„É≥„Ç∞„ÇíËÄÉÊÖÆ
			const padding = 32; // 1rem √ó 2 (top/bottom padding)
			const availableHeight = wrapperHeight - padding;

			// 1Ë°å„ÅÆÈ´ò„Åï„ÇíË®àÁÆóÔºàfont-size: 0.8rem, line-height: 1.4Ôºâ
			const fontSize = 0.8 * 16; // 0.8rem ‚Üí px
			const lineHeight = fontSize * 1.4; // line-height: 1.4

			// Ë°®Á§∫ÂèØËÉΩ„Å™Ë°åÊï∞„ÇíË®àÁÆó
			const visibleLines = Math.floor(availableHeight / lineHeight);

			console.log(`Wrapper height: ${wrapperHeight}px, Available height: ${availableHeight}px, Lines: ${visibleLines}`);

			// ÊúÄÂ∞èÂÄ§„Å®ÊúÄÂ§ßÂÄ§„ÅÆÁØÑÂõ≤ÂÜÖ„Å´Âà∂Èôê
			return Math.max(MIN_LINES, Math.min(MAX_LINES, visibleLines));
		} catch (error) {
			console.warn("Failed to calculate visible lines:", error);
			return 35; // „Ç®„É©„ÉºÊôÇ„ÅÆ„Éá„Éï„Ç©„É´„ÉàÂÄ§
		}
	}

	function updateChunkSize(): void {
		LINES_TO_DISPLAY = calculateVisibleLines();
		CHUNK_SIZE = LINES_TO_DISPLAY * BYTES_PER_LINE;
		console.log(
			`Updated display lines: ${LINES_TO_DISPLAY}, chunk size: ${CHUNK_SIZE}`,
		);
	}


	function formatFileSize(bytes: number): string {
		if (bytes === 0) return "0 Bytes";
		const k = 1024;
		const sizes = ["Bytes", "KB", "MB", "GB"];
		const i = Math.floor(Math.log(bytes) / Math.log(k));
		return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
	}

	function byteToHex(byte: number): string {
		return byte.toString(16).padStart(2, "0").toUpperCase();
	}

	function byteToChar(byte: number): string {
		return byte >= 0x20 && byte <= 0x7e ? String.fromCharCode(byte) : ".";
	}


	function getByteColorRGB(byte: number): {
		r: number;
		g: number;
		b: number;
	} {
		if (byte === 0x00) return { r: 255, g: 255, b: 255 }; // ÁôΩ
		if (byte >= 0x01 && byte <= 0x1f) return { r: 0, g: 255, b: 255 }; // Ê∞¥Ëâ≤
		if (byte >= 0x20 && byte <= 0x7e) return { r: 255, g: 0, b: 0 }; // Ëµ§
		return { r: 0, g: 0, b: 0 }; // Èªí
	}


	async function loadChunk(
		offset: number,
		size: number,
	): Promise<ArrayBuffer | null> {
		if (!currentFile) return null;

		const start = Math.max(0, offset);
		const end = Math.min(currentFile.size, offset + size);

		if (start >= end) return null;

		try {
			const slice = currentFile.slice(start, end);
			return await slice.arrayBuffer();
		} catch (error) {
			console.error("Error loading chunk:", error);
			return null;
		}
	}

	function updateScrollInfo(percentage: number, offset: number): void {
		scrollPosition.textContent = `${percentage.toFixed(1)}%`;
		offsetInfo.textContent = `Offset: 0x${offset.toString(16).padStart(8, "0").toUpperCase()}`;
	}

	function getMaxOffset(): number {
		if (!totalFileSize || totalFileSize <= CHUNK_SIZE) {
			return 0;
		}
		
		// „Éï„Ç°„Ç§„É´„ÅÆÊúÄÂæå„ÅÆ„Éê„Ç§„Éà„ÅåÂê´„Åæ„Çå„ÇãË°å„ÅÆÈñãÂßã„Ç™„Éï„Çª„ÉÉ„Éà
		const lastByteOffset = totalFileSize - 1;
		const lastLineStartOffset = Math.floor(lastByteOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
		
		return Math.max(0, lastLineStartOffset);
	}

	function calculateScrollbarDimensions(): {
		thumbHeight: number;
		thumbPosition: number;
		visible: boolean;
	} {
		if (!totalFileSize || totalFileSize <= CHUNK_SIZE) {
			return { thumbHeight: 0, thumbPosition: 0, visible: false };
		}

		const trackHeight = scrollbarTrack.clientHeight;
		const visibleRatio = CHUNK_SIZE / totalFileSize;
		const thumbHeight = Math.max(
			MIN_THUMB_HEIGHT,
			trackHeight * visibleRatio,
		);

		const maxOffset = getMaxOffset();
		const scrollProgress = maxOffset > 0 ? currentOffset / maxOffset : 0;
		const maxThumbPosition = trackHeight - thumbHeight;
		const thumbPosition = scrollProgress * maxThumbPosition;

		return { thumbHeight, thumbPosition, visible: true };
	}

	function updateScrollbarAppearance(): void {
		const { thumbHeight, thumbPosition, visible } =
			calculateScrollbarDimensions();

		if (visible) {
			customScrollbar.classList.remove("hidden");
			scrollbarThumb.style.height = `${thumbHeight}px`;
			scrollbarThumb.style.top = `${thumbPosition}px`;
		} else {
			customScrollbar.classList.add("hidden");
		}
	}

	function generateHexDump(buffer: ArrayBuffer, fileOffset: number): string {
		const bytes = new Uint8Array(buffer);
		let output = "";

		for (let i = 0; i < bytes.length; i += BYTES_PER_LINE) {
			const actualOffset = fileOffset + i;
			const lineOffset = actualOffset
				.toString(16)
				.padStart(8, "0")
				.toUpperCase();
			let hexPart = "";
			let textPart = "";

			for (let j = 0; j < BYTES_PER_LINE; j++) {
				const byteIndex = i + j;
				const currentByteOffset = fileOffset + byteIndex;
				
				if (byteIndex < bytes.length) {
					const byte = bytes[byteIndex];
					let hexByte = byteToHex(byte);
					let textByte = byteToChar(byte);
					
					// Ê§úÁ¥¢ÁµêÊûú„ÅÆ„Éè„Ç§„É©„Ç§„ÉàÂá¶ÁêÜ
					if (searchResultOffset !== -1 && searchPattern) {
						const searchEnd = searchResultOffset + searchPattern.length - 1;
						if (currentByteOffset >= searchResultOffset && currentByteOffset <= searchEnd) {
							hexByte = `<span class="search-highlight">${hexByte}</span>`;
							textByte = `<span class="search-highlight">${textByte}</span>`;
						}
					}
					
					hexPart += hexByte + " ";
					textPart += textByte;
				} else {
					hexPart += "   ";
					textPart += " ";
				}
			}

			output += `${lineOffset}: ${hexPart} |${textPart}|\n`;
		}

		return output;
	}

	function drawCanvas(buffer: ArrayBuffer): void {
		const bytes = new Uint8Array(buffer);
		const canvasWidth = canvas.width;
		const canvasHeight = canvas.height;

		// ImageData„Çí‰ΩøÁî®„Åó„ÅüÊúÄÈÅ©Âåñ„Åï„Çå„ÅüÊèèÁîª
		const imageData = ctx.createImageData(canvasWidth, canvasHeight);
		const data = imageData.data;

		// ËÉåÊôØ„ÇíÈªí„ÅßÂàùÊúüÂåñÔºà„Éá„Éº„Çø„Åå„Å™„ÅÑÈÉ®ÂàÜÔºâ
		for (let i = 0; i < data.length; i += 4) {
			data[i] = 0; // Red
			data[i + 1] = 0; // Green
			data[i + 2] = 0; // Blue
			data[i + 3] = 255; // Alpha
		}

		// „Éê„Ç§„Éà„Éá„Éº„Çø„ÇíËâ≤ÊÉÖÂ†±„Å´Â§âÊèõ
		const totalPixels = canvasWidth * canvasHeight;
		const bytesToProcess = Math.min(bytes.length, totalPixels);

		for (let i = 0; i < bytesToProcess; i++) {
			const byte = bytes[i];
			const color = getByteColorRGB(byte);
			const pixelIndex = i * 4;

			data[pixelIndex] = color.r; // Red
			data[pixelIndex + 1] = color.g; // Green
			data[pixelIndex + 2] = color.b; // Blue
			data[pixelIndex + 3] = 255; // Alpha
		}

		// ‰∏ÄÂ∫¶„Å´ÂÖ®‰Ωì„ÇíÊèèÁîª
		ctx.putImageData(imageData, 0, 0);
	}

	function setLoadingState(
		loading: boolean,
		message: string = "Ready",
	): void {
		isLoading = loading;
		if (loading) {
			statusMessage.textContent = message;
			statusMessage.classList.add("loading");
		} else {
			statusMessage.textContent = "Ready";
			statusMessage.classList.remove("loading");
		}
	}

	async function updateDisplay(): Promise<void> {
		if (!currentFile || isLoading) return;

		// „Ç≠„É£„ÉÉ„Ç∑„É•„ÉÅ„Çß„ÉÉ„ÇØÔºöÂêå„Åò„Ç™„Éï„Çª„ÉÉ„Éà„ÅÆÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
		if (lastUpdateOffset === currentOffset) return;

		setLoadingState(true, "Loading file data...");
		lastUpdateOffset = currentOffset;

		try {
			// HexdumpÁî®„ÅÆ„ÉÅ„É£„É≥„ÇØ„ÇíË™≠„ÅøËæº„ÅøÔºà„Éï„Ç°„Ç§„É´ÁµÇÁ´Ø„ÇíËÄÉÊÖÆÔºâ
			const remainingBytes = totalFileSize - currentOffset;
			const readSize = Math.min(CHUNK_SIZE, remainingBytes);
			const hexBuffer = await loadChunk(currentOffset, readSize);
			if (hexBuffer) {
				const hexDump = generateHexDump(hexBuffer, currentOffset);
				hexOutput.innerHTML = hexDump; // HTML„Å®„Åó„Å¶Ë°®Á§∫
			}

			// CanvasÁî®„ÅÆ„ÉÅ„É£„É≥„ÇØ„ÇíË™≠„ÅøËæº„ÅøÔºà„Çà„ÇäÂ§ß„Åç„Å™„ÉÅ„É£„É≥„ÇØÔºâ
			setLoadingState(true, "Rendering canvas...");
			const canvasBuffer = await loadChunk(
				currentOffset,
				CANVAS_CHUNK_SIZE,
			);
			if (canvasBuffer) {
				drawCanvas(canvasBuffer);
				canvas.classList.add("loaded");
			}

			// „Çπ„ÇØ„É≠„Éº„É´ÊÉÖÂ†±„ÇíÊõ¥Êñ∞
			const maxOffset = getMaxOffset();
			const percentage = maxOffset > 0 ? (currentOffset / maxOffset) * 100 : 0;
			updateScrollInfo(Math.min(percentage, 100), currentOffset);
			updateScrollbarAppearance();
		} catch (error) {
			console.error("Error updating display:", error);
			setLoadingState(false, "Error loading file");
		} finally {
			setLoadingState(false);
		}
	}

	function handleThumbMouseDown(event: MouseEvent): void {
		if (!currentFile || isSearching) return;

		isDragging = true;
		dragStartY = event.clientY;
		dragStartOffset = currentOffset;

		scrollbarThumb.classList.add("dragging");
		document.addEventListener("mousemove", handleThumbMouseMove);
		document.addEventListener("mouseup", handleThumbMouseUp);

		event.preventDefault();
	}

	const throttledUpdateDisplay = throttle(updateDisplay, 16); // 60FPSÁõ∏ÂΩì

	function handleThumbMouseMove(event: MouseEvent): void {
		if (!isDragging || !currentFile || isSearching) return;

		const deltaY = event.clientY - dragStartY;
		const trackHeight = scrollbarTrack.clientHeight;
		const { thumbHeight } = calculateScrollbarDimensions();
		const maxThumbPosition = trackHeight - thumbHeight;

		if (maxThumbPosition <= 0) return;

		const scrollRatio = deltaY / maxThumbPosition;
		const maxOffset = getMaxOffset();
		const newOffset = dragStartOffset + scrollRatio * maxOffset;

		currentOffset = Math.max(0, Math.min(maxOffset, newOffset));
		currentOffset =
			Math.floor(currentOffset / BYTES_PER_LINE) * BYTES_PER_LINE;

		throttledUpdateDisplay();
	}

	function handleThumbMouseUp(): void {
		if (!isDragging) return;

		isDragging = false;
		scrollbarThumb.classList.remove("dragging");
		document.removeEventListener("mousemove", handleThumbMouseMove);
		document.removeEventListener("mouseup", handleThumbMouseUp);
	}

	function handleTrackClick(event: MouseEvent): void {
		if (!currentFile || event.target === scrollbarThumb || isSearching) return;

		const rect = scrollbarTrack.getBoundingClientRect();
		const clickY = event.clientY - rect.top;
		const trackHeight = scrollbarTrack.clientHeight;
		const { thumbHeight } = calculateScrollbarDimensions();
		const maxThumbPosition = trackHeight - thumbHeight;

		if (maxThumbPosition <= 0) return;

		const scrollRatio = Math.max(0, Math.min(1, clickY / trackHeight));
		const maxOffset = getMaxOffset();
		currentOffset =
			Math.floor((scrollRatio * maxOffset) / BYTES_PER_LINE) *
			BYTES_PER_LINE;

		updateDisplay(); // „ÇØ„É™„ÉÉ„ÇØÊôÇ„ÅØÂç≥Â∫ß„Å´Êõ¥Êñ∞
	}

	// „Éï„Ç°„Ç§„É´ÈÅ∏Êäû„Çí„ÇØ„É™„Ç¢
	function clearFileSelection(): void {
		currentFile = null;
		totalFileSize = 0;
		currentOffset = 0;
		lastUpdateOffset = -1; // „Ç≠„É£„ÉÉ„Ç∑„É•„É™„Çª„ÉÉ„Éà
		customScrollbar.classList.add("hidden");
		hexOutput.textContent = "";
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		updateScrollInfo(0, 0);
		setLoadingState(false, "Ready");
		
		// Ê§úÁ¥¢ÁµêÊûú„Çí„ÇØ„É™„Ç¢
		searchResultOffset = -1;
		searchPattern = null;
		
		// Ê§úÁ¥¢„Éú„Çø„É≥„ÅÆÁä∂ÊÖã„ÇíÊõ¥Êñ∞
		updateSearchButtonState();
	}

	// „Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„ÅøÂá¶ÁêÜÔºàÂÖ±ÈÄöÔºâ
	async function loadFile(file: File): Promise<void> {
		currentFile = file;
		totalFileSize = file.size;
		currentOffset = 0;
		lastUpdateOffset = -1; // „Ç≠„É£„ÉÉ„Ç∑„É•„É™„Çª„ÉÉ„Éà

		fileName.textContent = file.name;
		fileSize.textContent = formatFileSize(file.size);

		// Ë°®Á§∫Ë°åÊï∞„ÇíÂãïÁöÑ„Å´Ë®àÁÆó„Åó„Å¶Êõ¥Êñ∞
		updateChunkSize();
		
		// Ê§úÁ¥¢„Éú„Çø„É≥„ÅÆÁä∂ÊÖã„ÇíÊõ¥Êñ∞
		updateSearchButtonState();
		
		// Ê§úÁ¥¢ÁµêÊûú„Çí„ÇØ„É™„Ç¢
		searchResultOffset = -1;
		searchPattern = null;

		try {
			await updateDisplay();
		} catch (error) {
			console.error("Error reading file:", error);
			setLoadingState(false, "Error loading file");
		}
	}

	async function handleFileChange(event: Event): Promise<void> {
		if (isSearching) return;
		
		const target = event.target as HTMLInputElement;
		const file = target.files?.[0];

		if (!file) {
			clearFileSelection();
			return;
		}

		await loadFile(file);
	}

	fileInput.addEventListener("change", handleFileChange);

	// „Éõ„Ç§„Éº„É´„Çπ„ÇØ„É≠„Éº„É´„Éè„É≥„Éâ„É©„Éº
	function handleWheelScroll(event: WheelEvent): void {
		if (!currentFile || isSearching) return;

		event.preventDefault();

		const scrollLines = 3; // ‰∏ÄÂ∫¶„Å´„Çπ„ÇØ„É≠„Éº„É´„Åô„ÇãË°åÊï∞
		const scrollAmount = scrollLines * BYTES_PER_LINE;
		const maxOffset = getMaxOffset();

		if (event.deltaY > 0) {
			// ‰∏ã„Çπ„ÇØ„É≠„Éº„É´
			currentOffset = Math.min(maxOffset, currentOffset + scrollAmount);
		} else {
			// ‰∏ä„Çπ„ÇØ„É≠„Éº„É´
			currentOffset = Math.max(0, currentOffset - scrollAmount);
		}

		currentOffset =
			Math.floor(currentOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
		throttledUpdateDisplay();
	}

	// „Ç≠„Éº„Éú„Éº„ÉâÊìç‰Ωú„Éè„É≥„Éâ„É©„Éº
	function handleKeyDown(event: KeyboardEvent): void {
		if (!currentFile || isSearching) return;

		const maxOffset = getMaxOffset();
		const pageSize = LINES_TO_DISPLAY * BYTES_PER_LINE;

		let handled = false;

		switch (event.key) {
			case "ArrowUp":
				currentOffset = Math.max(0, currentOffset - BYTES_PER_LINE);
				handled = true;
				break;
			case "ArrowDown":
				currentOffset = Math.min(
					maxOffset,
					currentOffset + BYTES_PER_LINE,
				);
				handled = true;
				break;
			case "PageUp":
				currentOffset = Math.max(0, currentOffset - pageSize);
				handled = true;
				break;
			case "PageDown":
				currentOffset = Math.min(maxOffset, currentOffset + pageSize);
				handled = true;
				break;
			case "Home":
				currentOffset = 0;
				handled = true;
				break;
			case "End":
				currentOffset = maxOffset;
				handled = true;
				break;
		}

		if (handled) {
			event.preventDefault();
			currentOffset =
				Math.floor(currentOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
			throttledUpdateDisplay();
		}
	}

	// „Çπ„ÇØ„É≠„Éº„É´„Éê„Éº„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
	scrollbarThumb.addEventListener("mousedown", handleThumbMouseDown);
	scrollbarTrack.addEventListener("click", handleTrackClick);

	// hex-output„Ç®„É™„Ç¢„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
	hexOutput.addEventListener("wheel", handleWheelScroll, { passive: false });

	// „Ç≠„Éº„Éú„Éº„Éâ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºÔºà„Éï„Ç©„Éº„Ç´„Çπ„ÅåÂøÖË¶ÅÔºâ
	hexOutput.setAttribute("tabindex", "0");
	hexOutput.addEventListener("keydown", handleKeyDown);

	// ÂàùÊúüÂåñÊôÇ„Å´ÂãïÁöÑË°åÊï∞„ÇíË®àÁÆó
	document.addEventListener("DOMContentLoaded", () => {
		// Â∞ë„ÅóÈÅÖÂª∂„Åï„Åõ„Å¶Ë¶ÅÁ¥†„ÅÆ„É¨„É≥„ÉÄ„É™„É≥„Ç∞„ÇíÂæÖ„Å§
		setTimeout(() => {
			updateChunkSize();
		}, 100);
	});

	// „Ç¶„Ç£„É≥„Éâ„Ç¶„É™„Çµ„Ç§„Ç∫ÊôÇ„ÅÆÂÜçË®àÁÆóÔºàthrottledÔºâ
	const throttledResize = throttle(() => {
		if (currentFile) {
			const oldChunkSize = CHUNK_SIZE;
			updateChunkSize();
			
			// „ÉÅ„É£„É≥„ÇØ„Çµ„Ç§„Ç∫„ÅåÂ§âÊõ¥„Åï„Çå„ÅüÂ†¥Âêà„ÅØÂÜçÊèèÁîª
			if (CHUNK_SIZE !== oldChunkSize) {
				lastUpdateOffset = -1; // „Ç≠„É£„ÉÉ„Ç∑„É•„É™„Çª„ÉÉ„Éà
				updateDisplay();
			}
		}
	}, 250); // „É™„Çµ„Ç§„Ç∫„ÅØ250msÈñìÈöî„ÅßÂà∂Èôê

	window.addEventListener("resize", throttledResize as EventListener);

	// OffsetÂÄ§„Ç∏„É£„É≥„ÉóÊ©üËÉΩ
	function handleOffsetClick(): void {
		if (!currentFile || isSearching) return;

		const input = prompt(
			"Jump to offset (hexadecimal, e.g., 1000 or 0x1000):",
			"0x" + currentOffset.toString(16).toUpperCase(),
		);

		if (input === null) return; // „Ç≠„É£„É≥„Çª„É´

		let targetOffset: number;
		try {
			// 16ÈÄ≤Êï∞„Å®„Åó„Å¶Ëß£ÊûêÔºà0x„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÅÆÊúâÁÑ°„ÇíÂïè„Çè„Å™„ÅÑÔºâ
			const cleanInput = input.trim().toLowerCase();
			if (cleanInput.startsWith("0x")) {
				targetOffset = parseInt(cleanInput, 16);
			} else {
				targetOffset = parseInt(cleanInput, 16);
			}

			if (isNaN(targetOffset) || targetOffset < 0) {
				alert("Invalid offset value. Please enter a valid hexadecimal number.");
				return;
			}

			// „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫ÂÜÖ„Å´Âà∂Èôê
			const maxOffset = getMaxOffset();
			targetOffset = Math.min(targetOffset, maxOffset);

			// Ë°åÂ¢ÉÁïå„Å´ÊèÉ„Åà„Çã
			targetOffset = Math.floor(targetOffset / BYTES_PER_LINE) * BYTES_PER_LINE;

			currentOffset = targetOffset;
			lastUpdateOffset = -1; // „Ç≠„É£„ÉÉ„Ç∑„É•„É™„Çª„ÉÉ„Éà
			updateDisplay();
		} catch (error) {
			alert("Invalid offset value. Please enter a valid hexadecimal number.");
		}
	}

	// OffsetÊÉÖÂ†±„Çí„ÇØ„É™„ÉÉ„ÇØÂèØËÉΩ„Å´„Åô„Çã
	offsetInfo.addEventListener("click", handleOffsetClick);

	// Canvas‰∏ä„Åß„ÅÆ„ÇØ„É™„ÉÉ„ÇØ„Ç∏„É£„É≥„ÉóÊ©üËÉΩ
	function handleCanvasClick(event: MouseEvent): void {
		if (!currentFile || isSearching) return;

		const rect = canvas.getBoundingClientRect();
		const x = event.clientX - rect.left;
		const y = event.clientY - rect.top;

		// CanvasÂÜÖ„ÅÆÂ∫ßÊ®ô„Çí„Éî„ÇØ„Çª„É´Â∫ßÊ®ô„Å´Â§âÊèõ
		const canvasX = Math.floor(x);
		const canvasY = Math.floor(y);

		// CanvasÊèèÁîªÈ†òÂüüÂÜÖ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
		if (canvasX < 0 || canvasX >= canvas.width || canvasY < 0 || canvasY >= canvas.height) {
			return;
		}

		// „ÇØ„É™„ÉÉ„ÇØ‰ΩçÁΩÆ„ÅÆ„Éê„Ç§„Éà„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíË®àÁÆó
		const bytesPerCanvasLine = CANVAS_BYTES_PER_LINE;
		const byteIndex = canvasY * bytesPerCanvasLine + canvasX;

		// ÁèæÂú®„ÅÆCanvasË°®Á§∫„Ç™„Éï„Çª„ÉÉ„Éà„ÇíËÄÉÊÖÆ„Åó„Å¶„Éï„Ç°„Ç§„É´ÂÜÖ„Ç™„Éï„Çª„ÉÉ„Éà„ÇíË®àÁÆó
		const fileByteOffset = currentOffset + byteIndex;

		// „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫ÂÜÖ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
		if (fileByteOffset >= totalFileSize) {
			return;
		}

		// 16„Éê„Ç§„ÉàÂ¢ÉÁïå„Å´‰∏∏„ÇÅ„Åü„Ç™„Éï„Çª„ÉÉ„Éà„ÇíË®àÁÆó
		const targetOffset = Math.floor(fileByteOffset / BYTES_PER_LINE) * BYTES_PER_LINE;

		// ÊúÄÂ§ß„Ç™„Éï„Çª„ÉÉ„ÉàÂÜÖ„Å´Âà∂Èôê
		const maxOffset = getMaxOffset();
		const clampedOffset = Math.min(targetOffset, maxOffset);

		// „Ç∏„É£„É≥„ÉóÂÆüË°å
		if (clampedOffset !== currentOffset) {
			currentOffset = clampedOffset;
			lastUpdateOffset = -1; // „Ç≠„É£„ÉÉ„Ç∑„É•„É™„Çª„ÉÉ„Éà
			updateDisplay();
		}
	}

	// Canvas„Å´„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíËøΩÂä†
	canvas.addEventListener("click", handleCanvasClick);

	// „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„ÉóÊ©üËÉΩ
	function handleDragEnter(event: DragEvent): void {
		if (isSearching) return;
		
		event.preventDefault();
		dragCounter++;
		if (dragCounter === 1) {
			dragOverlay.classList.remove("hidden");
		}
	}

	function handleDragOver(event: DragEvent): void {
		if (isSearching) return;
		
		event.preventDefault();
		event.dataTransfer!.dropEffect = "copy";
	}

	function handleDragLeave(event: DragEvent): void {
		if (isSearching) return;
		
		event.preventDefault();
		dragCounter--;
		if (dragCounter === 0) {
			dragOverlay.classList.add("hidden");
		}
	}

	function handleDrop(event: DragEvent): void {
		if (isSearching) return;
		
		event.preventDefault();
		dragCounter = 0;
		dragOverlay.classList.add("hidden");

		const files = event.dataTransfer?.files;
		if (files && files.length > 0) {
			const file = files[0];
			// ÂÖ±ÈÄö„ÅÆloadFileÈñ¢Êï∞„Çí‰ΩøÁî®
			loadFile(file);
		}
	}


	// „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„Éó„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„Çídocument„Å´ËøΩÂä†
	document.addEventListener("dragenter", handleDragEnter);
	document.addEventListener("dragover", handleDragOver);
	document.addEventListener("dragleave", handleDragLeave);
	document.addEventListener("drop", handleDrop);

	// Ê§úÁ¥¢Ê©üËÉΩ„ÅÆÂÆüË£Ö
	function getCurrentSearchMode(): 'ascii' | 'hex' {
		const checkedInput = document.querySelector('input[name="search-mode"]:checked') as HTMLInputElement;
		return checkedInput?.value as 'ascii' | 'hex' || 'ascii';
	}

	function updateSearchPlaceholder(): void {
		const mode = getCurrentSearchMode();
		if (mode === 'ascii') {
			searchInput.placeholder = 'Enter ASCII text (e.g., "Hello World")';
		} else {
			searchInput.placeholder = 'Enter hex bytes (e.g., "48 65 6C 6C 6F")';
		}
	}

	function validateSearchInput(input: string, mode: 'ascii' | 'hex'): boolean {
		if (!input.trim()) {
			return false;
		}

		if (mode === 'ascii') {
			// ASCIIÊñáÂ≠óÂàó„ÅØÂ∏∏„Å´ÊúâÂäπ
			return true;
		} else {
			// 16ÈÄ≤Êï∞„Éê„Ç§„Éà„Éë„Çø„Éº„É≥„ÅÆÊ§úË®º
			const hexPattern = /^[0-9A-Fa-f\s]+$/;
			if (!hexPattern.test(input)) {
				return false;
			}
			
			// „Çπ„Éö„Éº„Çπ„ÅßÂàÜÂâ≤„Åó„Å¶ÂêÑ„Éê„Ç§„Éà„ÇíÊ§úË®º
			const bytes = input.trim().split(/\s+/);
			return bytes.every(byte => {
				const parsed = parseInt(byte, 16);
				return !isNaN(parsed) && parsed >= 0 && parsed <= 255;
			});
		}
	}

	function convertToBytePattern(input: string, mode: 'ascii' | 'hex'): Uint8Array | null {
		if (!input.trim()) {
			return null;
		}

		try {
			if (mode === 'ascii') {
				// ASCIIÊñáÂ≠óÂàó„Çí„Éê„Ç§„ÉàÈÖçÂàó„Å´Â§âÊèõ
				return new TextEncoder().encode(input);
			} else {
				// 16ÈÄ≤Êï∞ÊñáÂ≠óÂàó„Çí„Éê„Ç§„ÉàÈÖçÂàó„Å´Â§âÊèõ
				const bytes = input.trim().split(/\s+/).map(byte => parseInt(byte, 16));
				return new Uint8Array(bytes);
			}
		} catch (error) {
			console.error('Pattern conversion error:', error);
			return null;
		}
	}

	function updateSearchButtonState(): void {
		const input = searchInput.value.trim();
		const mode = getCurrentSearchMode();
		const isValid = validateSearchInput(input, mode);
		
		if (isValid) {
			searchInput.classList.remove('invalid');
			searchToggleBtn.disabled = !currentFile;
		} else {
			searchInput.classList.add('invalid');
			searchToggleBtn.disabled = true;
		}
		
		// „Éú„Çø„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇíÊõ¥Êñ∞
		if (isSearching) {
			searchBtnText.textContent = 'Stop';
			searchToggleBtn.className = 'btn btn-secondary';
		} else {
			searchBtnText.textContent = 'Search';
			searchToggleBtn.className = 'btn btn-primary';
		}
		
		// Ê§úÁ¥¢‰∏≠„ÅØ„Çπ„ÇØ„É≠„Éº„É´„Éê„Éº„Å®„Éï„Ç°„Ç§„É´ÈÅ∏Êäû„ÇíÁÑ°ÂäπÂåñ
		if (isSearching) {
			customScrollbar.classList.add('disabled');
			fileInput.disabled = true;
		} else {
			customScrollbar.classList.remove('disabled');
			fileInput.disabled = false;
		}
	}

	// Ê§úÁ¥¢ÂÖ•Âäõ„ÅÆÂ§âÊõ¥„Ç§„Éô„É≥„Éà
	searchInput.addEventListener('input', updateSearchButtonState);

	// Ê§úÁ¥¢„É¢„Éº„Éâ„ÅÆÂ§âÊõ¥„Ç§„Éô„É≥„Éà
	searchModeInputs.forEach(input => {
		input.addEventListener('change', () => {
			updateSearchPlaceholder();
			updateSearchButtonState();
		});
	});

	// ÂàùÊúüÂåñ
	updateSearchPlaceholder();
	updateSearchButtonState();

	// „Éê„Ç§„Éä„É™Ê§úÁ¥¢„Ç¢„É´„Ç¥„É™„Ç∫„É†ÔºàBoyer-MooreÈ°û‰ººÔºâ
	function searchInBuffer(buffer: Uint8Array, pattern: Uint8Array, startPos: number = 0): number {
		if (pattern.length === 0 || pattern.length > buffer.length) {
			return -1;
		}

		// Á∞°Âçò„Å™Brute ForceÊ§úÁ¥¢ÔºàÂ∞è„Åï„Å™„Éë„Çø„Éº„É≥„Å´ÈÅ©„Åó„Å¶„ÅÑ„ÇãÔºâ
		for (let i = startPos; i <= buffer.length - pattern.length; i++) {
			let found = true;
			for (let j = 0; j < pattern.length; j++) {
				if (buffer[i + j] !== pattern[j]) {
					found = false;
					break;
				}
			}
			if (found) {
				return i;
			}
		}
		return -1;
	}

	// ÈùûÂêåÊúüÊ§úÁ¥¢Èñ¢Êï∞
	async function searchInFile(
		pattern: Uint8Array,
		startOffset: number = 0,
		onProgress?: (progress: number, currentOffset: number) => void
	): Promise<number> {
		if (!currentFile) {
			throw new Error('No file loaded');
		}

		const SEARCH_CHUNK_SIZE = 1024 * 1024; // 1MB chunks
		const OVERLAP_SIZE = pattern.length - 1; // „Éë„Çø„Éº„É≥„Åå„ÉÅ„É£„É≥„ÇØÂ¢ÉÁïå„Å´„Åæ„Åü„Åå„ÇãÂ†¥Âêà„ÅÆÈáçË§á
		let searchOffset = startOffset;
		let previousChunkEnd = new Uint8Array(0);

		while (searchOffset < totalFileSize) {
			// AbortController „Åß„Ç≠„É£„É≥„Çª„É´ÂèØËÉΩ„Å´„Åô„Çã
			if (searchAbortController?.signal.aborted) {
				throw new Error('Search aborted');
			}

			const remainingSize = totalFileSize - searchOffset;
			const chunkSize = Math.min(SEARCH_CHUNK_SIZE, remainingSize);
			
			// „ÉÅ„É£„É≥„ÇØ„ÇíË™≠„ÅøËæº„Åø
			const chunk = await loadChunk(searchOffset, chunkSize);
			if (!chunk) {
				break;
			}

			const chunkData = new Uint8Array(chunk);
			
			// Ââç„ÅÆ„ÉÅ„É£„É≥„ÇØ„ÅÆÁµÇÁ´Ø„Å®ÁµêÂêàÔºàÂ¢ÉÁïåÊ§úÁ¥¢Áî®Ôºâ
			const searchBuffer = new Uint8Array(previousChunkEnd.length + chunkData.length);
			searchBuffer.set(previousChunkEnd, 0);
			searchBuffer.set(chunkData, previousChunkEnd.length);

			// „Éê„ÉÉ„Éï„Ç°ÂÜÖ„Åß„Éë„Çø„Éº„É≥„ÇíÊ§úÁ¥¢
			const foundIndex = searchInBuffer(searchBuffer, pattern);
			if (foundIndex !== -1) {
				const fileOffset = searchOffset - previousChunkEnd.length + foundIndex;
				return fileOffset;
			}

			// ÈÄ≤Ë°åÁä∂Ê≥Å„ÇíÂ†±Âëä
			if (onProgress) {
				const progress = (searchOffset / totalFileSize) * 100;
				onProgress(progress, searchOffset);
			}

			// Ê¨°„ÅÆ„ÉÅ„É£„É≥„ÇØ„ÅÆ„Åü„ÇÅ„ÅÆÊ∫ñÂÇô
			previousChunkEnd = chunkData.slice(Math.max(0, chunkData.length - OVERLAP_SIZE));
			searchOffset += chunkSize;

			// UI„ÅÆÂøúÁ≠îÊÄß„Çí‰øù„Å§„Åü„ÇÅ„ÄÅÂ∞ë„ÅóÂæÖ„Å§
			await new Promise(resolve => setTimeout(resolve, 1));
		}

		return -1; // Ë¶ã„Å§„Åã„Çâ„Å™„Åã„Å£„Åü
	}

	// Ê§úÁ¥¢ÂÆüË°åÈñ¢Êï∞
	async function executeSearch(): Promise<void> {
		const input = searchInput.value.trim();
		const mode = getCurrentSearchMode();
		
		if (!input || !currentFile) {
			return;
		}

		// Ê§úÁ¥¢„Éë„Çø„Éº„É≥„ÇíÂ§âÊèõ
		const pattern = convertToBytePattern(input, mode);
		if (!pattern) {
			statusMessage.textContent = 'Invalid search pattern';
			statusMessage.classList.add('error');
			setTimeout(() => {
				statusMessage.textContent = 'Ready';
				statusMessage.classList.remove('error');
			}, 3000);
			return;
		}

		// Ê§úÁ¥¢Áä∂ÊÖã„ÇíË®≠ÂÆö
		isSearching = true;
		searchAbortController = new AbortController();
		searchPattern = pattern;
		
		// UIÁä∂ÊÖã„ÇíÊõ¥Êñ∞
		updateSearchButtonState();
		statusMessage.textContent = 'Searching...';
		statusMessage.classList.add('loading');

		try {
			// ÁèæÂú®„ÅÆ„Ç™„Éï„Çª„ÉÉ„Éà„Åã„ÇâÊ§úÁ¥¢ÈñãÂßã
			const startOffset = currentOffset;
			const foundOffset = await searchInFile(pattern, startOffset, (progress) => {
				statusMessage.textContent = `Searching... ${progress.toFixed(1)}%`;
			});

			if (foundOffset !== -1) {
				// Ê§úÁ¥¢ÊàêÂäü
				searchResultOffset = foundOffset;
				statusMessage.textContent = `Found at offset 0x${foundOffset.toString(16).toUpperCase()}`;
				statusMessage.classList.remove('loading');
				statusMessage.classList.add('success');
				
				// ÁµêÊûú„ÅÆ‰ΩçÁΩÆ„Å´„Ç∏„É£„É≥„Éó
				jumpToOffset(foundOffset);
			} else {
				// Ë¶ã„Å§„Åã„Çâ„Å™„Åã„Å£„Åü
				statusMessage.textContent = 'Pattern not found';
				statusMessage.classList.remove('loading');
				statusMessage.classList.add('warning');
			}
		} catch (error) {
			if (error instanceof Error && error.message === 'Search aborted') {
				statusMessage.textContent = 'Search cancelled';
				statusMessage.classList.remove('loading');
			} else {
				console.error('Search error:', error);
				statusMessage.textContent = 'Search error occurred';
				statusMessage.classList.remove('loading');
				statusMessage.classList.add('error');
			}
		} finally {
			// Ê§úÁ¥¢Áä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
			isSearching = false;
			searchAbortController = null;
			updateSearchButtonState();
			
			// 3ÁßíÂæå„Å´„Çπ„ÉÜ„Éº„Çø„Çπ„Çí„É™„Çª„ÉÉ„Éà
			setTimeout(() => {
				statusMessage.textContent = 'Ready';
				statusMessage.classList.remove('success', 'warning', 'error');
			}, 3000);
		}
	}

	// Ê§úÁ¥¢ÂÅúÊ≠¢Èñ¢Êï∞
	function stopSearch(): void {
		if (searchAbortController) {
			searchAbortController.abort();
		}
	}

	// „Ç™„Éï„Çª„ÉÉ„Éà„Å´„Ç∏„É£„É≥„Éó„Åô„ÇãÈñ¢Êï∞
	function jumpToOffset(targetOffset: number): void {
		const maxOffset = getMaxOffset();
		const clampedOffset = Math.min(targetOffset, maxOffset);
		const alignedOffset = Math.floor(clampedOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
		
		currentOffset = alignedOffset;
		lastUpdateOffset = -1; // „Ç≠„É£„ÉÉ„Ç∑„É•„É™„Çª„ÉÉ„Éà
		updateDisplay();
	}

	// Ê§úÁ¥¢„Éà„Ç∞„É´„Éú„Çø„É≥„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
	searchToggleBtn.addEventListener('click', () => {
		if (isSearching) {
			stopSearch();
		} else {
			executeSearch();
		}
	});

	// Enter„Ç≠„Éº„Åß„ÅÆÊ§úÁ¥¢ÂÆüË°å
	searchInput.addEventListener('keydown', (event) => {
		if (event.key === 'Enter' && !searchToggleBtn.disabled) {
			if (isSearching) {
				stopSearch();
			} else {
				executeSearch();
			}
		}
	});

</script>

<style>
	.file-info {
		display: flex;
		gap: 2rem;
		margin-top: 1rem;
	}

	.file-detail {
		display: flex;
		gap: 0.5rem;
		align-items: center;
	}

	.file-label {
		font-weight: 500;
		color: var(--text-secondary);
		min-width: 3rem;
	}

	#file-name {
		font-weight: 500;
		color: var(--text-primary);
		font-family: var(--font-mono);
		font-size: 0.875rem;
	}

	#file-size {
		color: var(--text-accent);
		font-family: var(--font-mono);
		font-size: 0.875rem;
	}

	.viewer-grid {
		display: grid;
		grid-template-columns: 1fr 300px;
		gap: 1.5rem;
		margin-top: 1.5rem;
	}

	.hex-output-container {
		height: calc(100vh - 400px); /* „Éò„ÉÉ„ÉÄ„Éº„ÇÑ„Ç≥„É≥„Éà„É≠„Éº„É´„ÅÆÈ´ò„Åï„ÇíËÄÉÊÖÆ */
		max-height: 800px;
		min-height: 400px; /* ÊúÄÂ∞èÈ´ò„Åï„Çí‰øùË®º */
		display: flex;
		flex-direction: column;
	}

	.hex-display-wrapper {
		flex: 1;
		display: flex;
		margin-top: 1rem;
		gap: 0; /* „Çπ„ÇØ„É≠„Éº„É´„Éê„Éº„ÇíÈöôÈñì„Å™„ÅèÈÖçÁΩÆ */
		min-height: 0; /* flexbox„ÅßÈÅ©Âàá„Å´Á∏ÆÂ∞è„Åï„Çå„Çã„Çà„ÅÜ„Å´ */
		overflow: hidden; /* ÂÜÖÂÆπ„Åå„ÅØ„ÅøÂá∫„Å™„ÅÑ„Çà„ÅÜ„Å´ */
	}

	.hex-output {
		flex: 1;
		font-family: var(--font-mono);
		font-size: 0.8rem;
		line-height: 1.4;
		color: var(--text-primary);
		white-space: pre;
		padding: 1rem;
		background: var(--bg-tertiary);
		border-radius: var(--radius-md);
		border: 1px solid var(--border-primary);
		overflow: hidden; /* ÂÜÖËîµ„Çπ„ÇØ„É≠„Éº„É´„ÇíÁÑ°ÂäπÂåñ */
		border-top-right-radius: 0;
		border-bottom-right-radius: 0;
		border-right: none;
		min-height: 200px; /* ÊúÄÂ∞èÈ´ò„Åï„ÇíË®≠ÂÆö */
	}

	.custom-scrollbar {
		width: 12px;
		background: var(--bg-tertiary);
		border: 1px solid var(--border-primary);
		border-left: none;
		border-top-right-radius: var(--radius-md);
		border-bottom-right-radius: var(--radius-md);
		position: relative;
		height: 100%; /* Ë¶™Ë¶ÅÁ¥†„ÅÆÈ´ò„Åï„Å´Âêà„Çè„Åõ„Çã */
	}

	.custom-scrollbar.hidden {
		display: none;
	}

	.custom-scrollbar.disabled {
		opacity: 0.5;
		pointer-events: none;
	}

	.scrollbar-track {
		position: absolute;
		top: 2px;
		left: 2px;
		right: 2px;
		bottom: 2px;
		background: var(--bg-secondary);
		border-radius: 4px;
		cursor: pointer;
	}

	.scrollbar-thumb {
		position: absolute;
		left: 0;
		right: 0;
		background: var(--text-muted);
		border-radius: 4px;
		cursor: pointer;
		transition: background-color 0.2s ease;
		min-height: 20px;
		opacity: 0.8;
	}

	.scrollbar-thumb:hover {
		background: var(--text-secondary);
		opacity: 1;
	}

	.scrollbar-thumb.dragging {
		background: var(--accent-primary);
		opacity: 1;
	}

	.scroll-info {
		display: flex;
		justify-content: space-between;
		margin-top: 0.5rem;
		padding: 0.5rem 0;
		font-size: 0.75rem;
		color: var(--text-secondary);
		font-family: var(--font-mono);
		flex-shrink: 0; /* flexbox„ÅßÁ∏ÆÂ∞è„Åï„Çå„Å™„ÅÑ„Çà„ÅÜ„Å´ */
		border-top: 1px solid var(--border-secondary);
	}

	#offset-info {
		cursor: pointer;
		padding: 0.25rem 0.5rem;
		border-radius: var(--radius-sm);
		transition: all 0.2s ease;
	}

	#offset-info:hover {
		background: var(--bg-card);
		color: var(--accent-primary);
		transform: translateY(-1px);
	}


	.canvas-container {
		display: flex;
		flex-direction: column;
		max-height: 800px;
	}

	.canvas-wrapper {
		flex: 1;
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 1rem;
		margin-top: 1rem;
	}

	#hex-canvas {
		border: 1px solid var(--border-primary);
		image-rendering: pixelated;
		background: var(--bg-tertiary);
		box-shadow: var(--shadow-md);
		transition: box-shadow 0.2s ease;
		cursor: pointer;
	}

	#hex-canvas:hover {
		box-shadow: var(--shadow-lg), 0 0 10px rgba(59, 130, 246, 0.3);
		border-color: var(--accent-primary);
	}

	.color-legend {
		display: grid;
		grid-template-columns: repeat(2, 1fr);
		gap: 0.5rem;
		width: 100%;
		max-width: 256px;
	}

	.legend-item {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		font-size: 0.75rem;
		color: var(--text-secondary);
	}

	.color-sample {
		width: 12px;
		height: 12px;
		border-radius: 2px;
		flex-shrink: 0;
	}

	.format-info {
		font-size: 0.75rem;
		color: var(--text-muted);
		font-family: var(--font-mono);
	}

	/* Status bar */
	.status-bar {
		margin-top: 1rem;
		padding: 0.5rem 1rem;
		background: var(--bg-tertiary);
		border: 1px solid var(--border-primary);
		border-radius: var(--radius-md);
		display: flex;
		align-items: center;
		min-height: 2rem;
	}

	#status-message {
		font-size: 0.875rem;
		color: var(--text-secondary);
		font-family: var(--font-mono);
	}

	#status-message.loading {
		color: var(--accent-primary);
		position: relative;
	}

	#status-message.loading::after {
		content: "";
		width: 12px;
		height: 12px;
		border: 2px solid var(--border-primary);
		border-top: 2px solid var(--accent-primary);
		border-radius: 50%;
		animation: spin 1s linear infinite;
		margin-left: 0.5rem;
		display: inline-block;
	}

	#status-message.success {
		color: var(--accent-success);
	}

	#status-message.warning {
		color: var(--accent-warning);
	}

	#status-message.error {
		color: var(--accent-error);
	}

	@keyframes spin {
		0% {
			transform: rotate(0deg);
		}
		100% {
			transform: rotate(360deg);
		}
	}

	/* Empty state */
	.hex-output:empty::before {
		content: "Select a file to view its hex dump...";
		color: var(--text-muted);
		font-style: italic;
		display: flex;
		align-items: center;
		justify-content: center;
		height: 100%;
	}

	/* Animation for canvas */
	@keyframes canvasLoad {
		0% {
			opacity: 0;
			transform: scale(0.9);
		}
		100% {
			opacity: 1;
			transform: scale(1);
		}
	}

	#hex-canvas.loaded {
		animation: canvasLoad 0.3s ease-out;
	}

	/* Hover effects */
	.glass-card:hover {
		transform: translateY(-2px);
	}

	.result-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 0;
		padding-bottom: 0;
	}

	.result-header h3 {
		margin: 0;
		font-size: 1.1rem;
	}

	/* File input enhancements */
	.file-input:hover .file-input-label {
		border-color: var(--accent-primary);
		background: var(--bg-card);
		color: var(--text-primary);
	}

	.file-input.has-file .file-input-label {
		border-color: var(--accent-success);
		background: var(--bg-card);
		color: var(--accent-success);
	}

	.file-input input:disabled + .file-input-label {
		opacity: 0.5;
		cursor: not-allowed;
		background: var(--bg-secondary);
		border-color: var(--border-secondary);
		color: var(--text-muted);
	}

	/* Ê§úÁ¥¢„Éë„Éç„É´ */
	.search-panel {
		margin-bottom: 1.5rem;
	}

	.search-controls {
		display: flex;
		gap: 1rem;
		align-items: flex-end;
	}

	.search-input-group {
		flex: 1;
		display: flex;
		flex-direction: column;
		gap: 0.5rem;
	}

	.search-input {
		width: 100%;
		padding: 0.5rem 0.75rem;
		background: var(--bg-tertiary);
		border: 1px solid var(--border-primary);
		border-radius: var(--radius-md);
		color: var(--text-primary);
		font-size: 0.875rem;
		font-family: var(--font-mono);
		transition: all 0.2s ease;
	}

	.search-input:focus {
		outline: none;
		border-color: var(--accent-primary);
		box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
	}

	.search-input.invalid {
		border-color: var(--accent-error);
		box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.1);
	}

	.search-mode {
		display: flex;
		gap: 1rem;
	}

	.search-mode-option {
		display: flex;
		align-items: center;
		gap: 0.375rem;
		cursor: pointer;
		font-size: 0.8rem;
		color: var(--text-secondary);
		transition: color 0.2s ease;
	}

	.search-mode-option:hover {
		color: var(--text-primary);
	}

	.search-mode-option input[type="radio"] {
		width: 0.875rem;
		height: 0.875rem;
		appearance: none;
		background: var(--bg-tertiary);
		border: 1px solid var(--border-primary);
		border-radius: 50%;
		position: relative;
		cursor: pointer;
		transition: all 0.2s ease;
	}

	.search-mode-option input[type="radio"]:checked {
		background: var(--accent-primary);
		border-color: var(--accent-primary);
	}

	.search-mode-option input[type="radio"]:checked::after {
		content: '';
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		width: 5px;
		height: 5px;
		background: white;
		border-radius: 50%;
	}

	/* Ê§úÁ¥¢ÁµêÊûú„ÅÆ„Éè„Ç§„É©„Ç§„Éà */
	.search-highlight {
		background: var(--accent-primary);
		color: white;
		padding: 0 2px;
		border-radius: 2px;
		font-weight: bold;
	}

	/* „Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„Éó„Ç™„Éº„Éê„Éº„É¨„Ç§ */
	.drag-overlay {
		position: fixed;
		top: 0;
		left: 0;
		width: 100vw;
		height: 100vh;
		background: rgba(59, 130, 246, 0.1);
		backdrop-filter: blur(5px);
		z-index: 9999;
		display: flex;
		align-items: center;
		justify-content: center;
		pointer-events: none;
		transition: opacity 0.2s ease;
	}

	.drag-overlay.hidden {
		opacity: 0;
		pointer-events: none;
		display: none;
	}

	.drag-message {
		background: var(--bg-card);
		border: 2px dashed var(--accent-primary);
		border-radius: var(--radius-lg);
		padding: 3rem;
		text-align: center;
		box-shadow: var(--shadow-xl);
		transform: scale(0.9);
		animation: dragPulse 1.5s ease-in-out infinite;
	}

	.drag-icon {
		font-size: 4rem;
		margin-bottom: 1rem;
		opacity: 0.8;
	}

	.drag-text {
		font-size: 1.5rem;
		font-weight: 600;
		color: var(--accent-primary);
		margin: 0;
	}

	@keyframes dragPulse {
		0%, 100% {
			transform: scale(0.9);
			opacity: 0.8;
		}
		50% {
			transform: scale(1);
			opacity: 1;
		}
	}
</style>
