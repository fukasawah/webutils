---

---

<div class="tool-container">
	<div class="tool-header">
		<h1>ğŸ“Š Hex Dump Tool</h1>
		<p>
			Binary file analysis with hexdump display and visual representation
		</p>
	</div>

	<div class="glass-card tool-controls">
		<div class="file-input">
			<input type="file" id="file-input" accept="*/*" />
			<div class="file-input-label">
				<span>ğŸ“ Choose Binary File</span>
			</div>
		</div>
		<div class="file-info">
			<div class="file-detail">
				<span class="file-label">File:</span>
				<span id="file-name">No file selected</span>
			</div>
			<div class="file-detail">
				<span class="file-label">Size:</span>
				<span id="file-size">-</span>
			</div>
		</div>
	</div>

	<div class="viewer-grid">
		<div class="glass-card hex-output-container">
			<div class="result-header">
				<h3>Hex Dump Output</h3>
				<div class="format-info">16 bytes per line</div>
			</div>
			<div class="hex-display-wrapper">
				<div id="hex-output" class="hex-output"></div>
				<div class="custom-scrollbar" id="custom-scrollbar">
					<div class="scrollbar-track" id="scrollbar-track">
						<div class="scrollbar-thumb" id="scrollbar-thumb"></div>
					</div>
				</div>
			</div>
			<div class="scroll-info">
				<span id="scroll-position">0%</span>
				<span id="offset-info">Offset: 0x00000000</span>
			</div>
		</div>

		<div class="glass-card canvas-container">
			<div class="result-header">
				<h3>Visual Representation</h3>
				<div class="format-info">256 bytes per line</div>
			</div>
			<div class="canvas-wrapper">
				<canvas id="hex-canvas" width="256" height="400"></canvas>
				<div class="color-legend">
					<div class="legend-item">
						<div
							class="color-sample"
							style="background: #FFFFFF; border: 1px solid var(--border-primary);"
						>
						</div>
						<span>0x00</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #00FFFF;">
						</div>
						<span>0x01-0x1F</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #FF0000;">
						</div>
						<span>0x20-0x7E</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #000000;">
						</div>
						<span>0x80-0xFF</span>
					</div>
				</div>
			</div>
		</div>
	</div>

	<div class="status-bar">
		<span id="status-message">Ready</span>
	</div>
	
	<!-- ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
	<div id="drag-overlay" class="drag-overlay hidden">
		<div class="drag-message">
			<div class="drag-icon">ğŸ“</div>
			<div class="drag-text">Drop file here to analyze</div>
		</div>
	</div>
</div>

<script>
	const fileInput = document.getElementById("file-input") as HTMLInputElement;
	const fileName = document.getElementById("file-name") as HTMLSpanElement;
	const fileSize = document.getElementById("file-size") as HTMLSpanElement;
	const hexOutput = document.getElementById("hex-output") as HTMLDivElement;
	const canvas = document.getElementById("hex-canvas") as HTMLCanvasElement;
	const ctx = canvas.getContext("2d", { willReadFrequently: false })!;

	// Canvasæç”»ã®æœ€é©åŒ–è¨­å®š
	ctx.imageSmoothingEnabled = false;
	const customScrollbar = document.getElementById(
		"custom-scrollbar",
	) as HTMLDivElement;
	const scrollbarTrack = document.getElementById(
		"scrollbar-track",
	) as HTMLDivElement;
	const scrollbarThumb = document.getElementById(
		"scrollbar-thumb",
	) as HTMLDivElement;
	const scrollPosition = document.getElementById(
		"scroll-position",
	) as HTMLSpanElement;
	const offsetInfo = document.getElementById(
		"offset-info",
	) as HTMLSpanElement;
	const statusMessage = document.getElementById(
		"status-message",
	) as HTMLSpanElement;
	const dragOverlay = document.getElementById("drag-overlay") as HTMLDivElement;

	let currentFile: File | null = null;
	let totalFileSize = 0;
	let currentOffset = 0;
	let isDragging = false;
	let dragStartY = 0;
	let dragStartOffset = 0;
	let isLoading = false;
	let lastUpdateOffset = -1;
	let dragCounter = 0; // ãƒ‰ãƒ©ãƒƒã‚°ã‚¤ãƒ™ãƒ³ãƒˆã®é‡è¤‡é˜²æ­¢
	
	const BYTES_PER_LINE = 16;
	const CANVAS_BYTES_PER_LINE = 256;
	let LINES_TO_DISPLAY = 50; // å‹•çš„ã«å¤‰æ›´ã•ã‚Œã‚‹
	let CHUNK_SIZE = LINES_TO_DISPLAY * BYTES_PER_LINE; // è¡¨ç¤ºç”¨ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚º
	const CANVAS_CHUNK_SIZE = 400 * CANVAS_BYTES_PER_LINE; // Canvasç”¨ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚º
	const MIN_THUMB_HEIGHT = 20; // æœ€å°ã‚µãƒ ã®é«˜ã•ï¼ˆpxï¼‰
	const MIN_LINES = 10; // æœ€å°è¡¨ç¤ºè¡Œæ•°
	const MAX_LINES = 100; // æœ€å¤§è¡¨ç¤ºè¡Œæ•°

	function throttle(func: Function, delay: number): Function {
		let timeoutId: number | null | NodeJS.Timeout = null;
		let lastExecTime = 0;
		return function (...args: any[]) {
			const currentTime = Date.now();
			if (currentTime - lastExecTime > delay) {
				func(...args);
				lastExecTime = currentTime;
			} else if (!timeoutId) {
				timeoutId = setTimeout(
					() => {
						func(...args);
						lastExecTime = Date.now();
						timeoutId = null;
					},
					delay - (currentTime - lastExecTime),
				);
			}
		};
	}

	function calculateVisibleLines(): number {
		try {
			// hex-outputè¦ç´ ã®å®Ÿéš›ã®é«˜ã•ã‚’å–å¾—
			const containerHeight = hexOutput.clientHeight;
			if (containerHeight === 0) {
				return 35; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
			}

			// ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’é™¤ã„ãŸåˆ©ç”¨å¯èƒ½ãªé«˜ã•
			const padding = 32; // 1rem Ã— 2 (top/bottom padding)
			const availableHeight = containerHeight - padding;

			// 1è¡Œã®é«˜ã•ã‚’è¨ˆç®—ï¼ˆfont-size: 0.8rem, line-height: 1.4ï¼‰
			const fontSize = 0.8 * 16; // 0.8rem â†’ px
			const lineHeight = fontSize * 1.4; // line-height: 1.4

			// è¡¨ç¤ºå¯èƒ½ãªè¡Œæ•°ã‚’è¨ˆç®—
			const visibleLines = Math.floor(availableHeight / lineHeight);

			// æœ€å°å€¤ã¨æœ€å¤§å€¤ã®ç¯„å›²å†…ã«åˆ¶é™
			return Math.max(MIN_LINES, Math.min(MAX_LINES, visibleLines));
		} catch (error) {
			console.warn("Failed to calculate visible lines:", error);
			return 35; // ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
		}
	}

	function updateChunkSize(): void {
		LINES_TO_DISPLAY = calculateVisibleLines();
		CHUNK_SIZE = LINES_TO_DISPLAY * BYTES_PER_LINE;
		console.log(
			`Updated display lines: ${LINES_TO_DISPLAY}, chunk size: ${CHUNK_SIZE}`,
		);
	}


	function formatFileSize(bytes: number): string {
		if (bytes === 0) return "0 Bytes";
		const k = 1024;
		const sizes = ["Bytes", "KB", "MB", "GB"];
		const i = Math.floor(Math.log(bytes) / Math.log(k));
		return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
	}

	function byteToHex(byte: number): string {
		return byte.toString(16).padStart(2, "0").toUpperCase();
	}

	function byteToChar(byte: number): string {
		return byte >= 0x20 && byte <= 0x7e ? String.fromCharCode(byte) : ".";
	}


	function getByteColorRGB(byte: number): {
		r: number;
		g: number;
		b: number;
	} {
		if (byte === 0x00) return { r: 255, g: 255, b: 255 }; // ç™½
		if (byte >= 0x01 && byte <= 0x1f) return { r: 0, g: 255, b: 255 }; // æ°´è‰²
		if (byte >= 0x20 && byte <= 0x7e) return { r: 255, g: 0, b: 0 }; // èµ¤
		return { r: 0, g: 0, b: 0 }; // é»’
	}


	async function loadChunk(
		offset: number,
		size: number,
	): Promise<ArrayBuffer | null> {
		if (!currentFile) return null;

		const start = Math.max(0, offset);
		const end = Math.min(currentFile.size, offset + size);

		if (start >= end) return null;

		try {
			const slice = currentFile.slice(start, end);
			return await slice.arrayBuffer();
		} catch (error) {
			console.error("Error loading chunk:", error);
			return null;
		}
	}

	function updateScrollInfo(percentage: number, offset: number): void {
		scrollPosition.textContent = `${percentage.toFixed(1)}%`;
		offsetInfo.textContent = `Offset: 0x${offset.toString(16).padStart(8, "0").toUpperCase()}`;
	}

	function getMaxOffset(): number {
		if (!totalFileSize || totalFileSize <= CHUNK_SIZE) {
			return 0;
		}
		
		// ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€å¾Œã®ãƒã‚¤ãƒˆãŒå«ã¾ã‚Œã‚‹è¡Œã®é–‹å§‹ã‚ªãƒ•ã‚»ãƒƒãƒˆ
		const lastByteOffset = totalFileSize - 1;
		const lastLineStartOffset = Math.floor(lastByteOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
		
		return Math.max(0, lastLineStartOffset);
	}

	function calculateScrollbarDimensions(): {
		thumbHeight: number;
		thumbPosition: number;
		visible: boolean;
	} {
		if (!totalFileSize || totalFileSize <= CHUNK_SIZE) {
			return { thumbHeight: 0, thumbPosition: 0, visible: false };
		}

		const trackHeight = scrollbarTrack.clientHeight;
		const visibleRatio = CHUNK_SIZE / totalFileSize;
		const thumbHeight = Math.max(
			MIN_THUMB_HEIGHT,
			trackHeight * visibleRatio,
		);

		const maxOffset = getMaxOffset();
		const scrollProgress = maxOffset > 0 ? currentOffset / maxOffset : 0;
		const maxThumbPosition = trackHeight - thumbHeight;
		const thumbPosition = scrollProgress * maxThumbPosition;

		return { thumbHeight, thumbPosition, visible: true };
	}

	function updateScrollbarAppearance(): void {
		const { thumbHeight, thumbPosition, visible } =
			calculateScrollbarDimensions();

		if (visible) {
			customScrollbar.classList.remove("hidden");
			scrollbarThumb.style.height = `${thumbHeight}px`;
			scrollbarThumb.style.top = `${thumbPosition}px`;
		} else {
			customScrollbar.classList.add("hidden");
		}
	}

	function generateHexDump(buffer: ArrayBuffer, fileOffset: number): string {
		const bytes = new Uint8Array(buffer);
		let output = "";

		for (let i = 0; i < bytes.length; i += BYTES_PER_LINE) {
			const actualOffset = fileOffset + i;
			const lineOffset = actualOffset
				.toString(16)
				.padStart(8, "0")
				.toUpperCase();
			let hexPart = "";
			let textPart = "";

			for (let j = 0; j < BYTES_PER_LINE; j++) {
				const byteIndex = i + j;
				
				if (byteIndex < bytes.length) {
					const byte = bytes[byteIndex];
					hexPart += byteToHex(byte) + " ";
					textPart += byteToChar(byte);
				} else {
					hexPart += "   ";
					textPart += " ";
				}
			}

			output += `${lineOffset}: ${hexPart} |${textPart}|\n`;
		}

		return output;
	}

	function drawCanvas(buffer: ArrayBuffer): void {
		const bytes = new Uint8Array(buffer);
		const canvasWidth = canvas.width;
		const canvasHeight = canvas.height;

		// ImageDataã‚’ä½¿ç”¨ã—ãŸæœ€é©åŒ–ã•ã‚ŒãŸæç”»
		const imageData = ctx.createImageData(canvasWidth, canvasHeight);
		const data = imageData.data;

		// èƒŒæ™¯ã‚’é»’ã§åˆæœŸåŒ–ï¼ˆãƒ‡ãƒ¼ã‚¿ãŒãªã„éƒ¨åˆ†ï¼‰
		for (let i = 0; i < data.length; i += 4) {
			data[i] = 0; // Red
			data[i + 1] = 0; // Green
			data[i + 2] = 0; // Blue
			data[i + 3] = 255; // Alpha
		}

		// ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’è‰²æƒ…å ±ã«å¤‰æ›
		const totalPixels = canvasWidth * canvasHeight;
		const bytesToProcess = Math.min(bytes.length, totalPixels);

		for (let i = 0; i < bytesToProcess; i++) {
			const byte = bytes[i];
			const color = getByteColorRGB(byte);
			const pixelIndex = i * 4;

			data[pixelIndex] = color.r; // Red
			data[pixelIndex + 1] = color.g; // Green
			data[pixelIndex + 2] = color.b; // Blue
			data[pixelIndex + 3] = 255; // Alpha
		}

		// ä¸€åº¦ã«å…¨ä½“ã‚’æç”»
		ctx.putImageData(imageData, 0, 0);
	}

	function setLoadingState(
		loading: boolean,
		message: string = "Ready",
	): void {
		isLoading = loading;
		if (loading) {
			statusMessage.textContent = message;
			statusMessage.classList.add("loading");
		} else {
			statusMessage.textContent = "Ready";
			statusMessage.classList.remove("loading");
		}
	}

	async function updateDisplay(): Promise<void> {
		if (!currentFile || isLoading) return;

		// ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯ï¼šåŒã˜ã‚ªãƒ•ã‚»ãƒƒãƒˆã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
		if (lastUpdateOffset === currentOffset) return;

		setLoadingState(true, "Loading file data...");
		lastUpdateOffset = currentOffset;

		try {
			// Hexdumpç”¨ã®ãƒãƒ£ãƒ³ã‚¯ã‚’èª­ã¿è¾¼ã¿ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«çµ‚ç«¯ã‚’è€ƒæ…®ï¼‰
			const remainingBytes = totalFileSize - currentOffset;
			const readSize = Math.min(CHUNK_SIZE, remainingBytes);
			const hexBuffer = await loadChunk(currentOffset, readSize);
			if (hexBuffer) {
				const hexDump = generateHexDump(hexBuffer, currentOffset);
				hexOutput.innerHTML = hexDump; // HTMLã¨ã—ã¦è¡¨ç¤º
			}

			// Canvasç”¨ã®ãƒãƒ£ãƒ³ã‚¯ã‚’èª­ã¿è¾¼ã¿ï¼ˆã‚ˆã‚Šå¤§ããªãƒãƒ£ãƒ³ã‚¯ï¼‰
			setLoadingState(true, "Rendering canvas...");
			const canvasBuffer = await loadChunk(
				currentOffset,
				CANVAS_CHUNK_SIZE,
			);
			if (canvasBuffer) {
				drawCanvas(canvasBuffer);
				canvas.classList.add("loaded");
			}

			// ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æƒ…å ±ã‚’æ›´æ–°
			const maxOffset = getMaxOffset();
			const percentage = maxOffset > 0 ? (currentOffset / maxOffset) * 100 : 0;
			updateScrollInfo(Math.min(percentage, 100), currentOffset);
			updateScrollbarAppearance();
		} catch (error) {
			console.error("Error updating display:", error);
			setLoadingState(false, "Error loading file");
		} finally {
			setLoadingState(false);
		}
	}

	function handleThumbMouseDown(event: MouseEvent): void {
		if (!currentFile) return;

		isDragging = true;
		dragStartY = event.clientY;
		dragStartOffset = currentOffset;

		scrollbarThumb.classList.add("dragging");
		document.addEventListener("mousemove", handleThumbMouseMove);
		document.addEventListener("mouseup", handleThumbMouseUp);

		event.preventDefault();
	}

	const throttledUpdateDisplay = throttle(updateDisplay, 16); // 60FPSç›¸å½“

	function handleThumbMouseMove(event: MouseEvent): void {
		if (!isDragging || !currentFile) return;

		const deltaY = event.clientY - dragStartY;
		const trackHeight = scrollbarTrack.clientHeight;
		const { thumbHeight } = calculateScrollbarDimensions();
		const maxThumbPosition = trackHeight - thumbHeight;

		if (maxThumbPosition <= 0) return;

		const scrollRatio = deltaY / maxThumbPosition;
		const maxOffset = getMaxOffset();
		const newOffset = dragStartOffset + scrollRatio * maxOffset;

		currentOffset = Math.max(0, Math.min(maxOffset, newOffset));
		currentOffset =
			Math.floor(currentOffset / BYTES_PER_LINE) * BYTES_PER_LINE;

		throttledUpdateDisplay();
	}

	function handleThumbMouseUp(): void {
		if (!isDragging) return;

		isDragging = false;
		scrollbarThumb.classList.remove("dragging");
		document.removeEventListener("mousemove", handleThumbMouseMove);
		document.removeEventListener("mouseup", handleThumbMouseUp);
	}

	function handleTrackClick(event: MouseEvent): void {
		if (!currentFile || event.target === scrollbarThumb) return;

		const rect = scrollbarTrack.getBoundingClientRect();
		const clickY = event.clientY - rect.top;
		const trackHeight = scrollbarTrack.clientHeight;
		const { thumbHeight } = calculateScrollbarDimensions();
		const maxThumbPosition = trackHeight - thumbHeight;

		if (maxThumbPosition <= 0) return;

		const scrollRatio = Math.max(0, Math.min(1, clickY / trackHeight));
		const maxOffset = getMaxOffset();
		currentOffset =
			Math.floor((scrollRatio * maxOffset) / BYTES_PER_LINE) *
			BYTES_PER_LINE;

		updateDisplay(); // ã‚¯ãƒªãƒƒã‚¯æ™‚ã¯å³åº§ã«æ›´æ–°
	}

	async function handleFileChange(event: Event): Promise<void> {
		const target = event.target as HTMLInputElement;
		const file = target.files?.[0];

		if (!file) {
			currentFile = null;
			totalFileSize = 0;
			currentOffset = 0;
			lastUpdateOffset = -1; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒªã‚»ãƒƒãƒˆ
			customScrollbar.classList.add("hidden");
			hexOutput.textContent = "";
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			updateScrollInfo(0, 0);
			statusMessage.textContent = "Ready";
			statusMessage.classList.remove("loading");
			return;
		}

		currentFile = file;
		totalFileSize = file.size;
		currentOffset = 0;
		lastUpdateOffset = -1; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒªã‚»ãƒƒãƒˆ

		fileName.textContent = file.name;
		fileSize.textContent = formatFileSize(file.size);

		// è¡¨ç¤ºè¡Œæ•°ã‚’å‹•çš„ã«è¨ˆç®—ã—ã¦æ›´æ–°
		updateChunkSize();

		try {
			await updateDisplay();
		} catch (error) {
			console.error("Error reading file:", error);
			statusMessage.textContent = "Error loading file";
			statusMessage.classList.remove("loading");
		}
	}

	fileInput.addEventListener("change", handleFileChange);

	// ãƒ›ã‚¤ãƒ¼ãƒ«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
	function handleWheelScroll(event: WheelEvent): void {
		if (!currentFile) return;

		event.preventDefault();

		const scrollLines = 3; // ä¸€åº¦ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã™ã‚‹è¡Œæ•°
		const scrollAmount = scrollLines * BYTES_PER_LINE;
		const maxOffset = getMaxOffset();

		if (event.deltaY > 0) {
			// ä¸‹ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
			currentOffset = Math.min(maxOffset, currentOffset + scrollAmount);
		} else {
			// ä¸Šã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
			currentOffset = Math.max(0, currentOffset - scrollAmount);
		}

		currentOffset =
			Math.floor(currentOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
		throttledUpdateDisplay();
	}

	// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œãƒãƒ³ãƒ‰ãƒ©ãƒ¼
	function handleKeyDown(event: KeyboardEvent): void {
		if (!currentFile) return;

		const maxOffset = getMaxOffset();
		const pageSize = LINES_TO_DISPLAY * BYTES_PER_LINE;

		let handled = false;

		switch (event.key) {
			case "ArrowUp":
				currentOffset = Math.max(0, currentOffset - BYTES_PER_LINE);
				handled = true;
				break;
			case "ArrowDown":
				currentOffset = Math.min(
					maxOffset,
					currentOffset + BYTES_PER_LINE,
				);
				handled = true;
				break;
			case "PageUp":
				currentOffset = Math.max(0, currentOffset - pageSize);
				handled = true;
				break;
			case "PageDown":
				currentOffset = Math.min(maxOffset, currentOffset + pageSize);
				handled = true;
				break;
			case "Home":
				currentOffset = 0;
				handled = true;
				break;
			case "End":
				currentOffset = maxOffset;
				handled = true;
				break;
		}

		if (handled) {
			event.preventDefault();
			currentOffset =
				Math.floor(currentOffset / BYTES_PER_LINE) * BYTES_PER_LINE;
			throttledUpdateDisplay();
		}
	}

	// ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
	scrollbarThumb.addEventListener("mousedown", handleThumbMouseDown);
	scrollbarTrack.addEventListener("click", handleTrackClick);

	// hex-outputã‚¨ãƒªã‚¢ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
	hexOutput.addEventListener("wheel", handleWheelScroll, { passive: false });

	// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ï¼ˆãƒ•ã‚©ãƒ¼ã‚«ã‚¹ãŒå¿…è¦ï¼‰
	hexOutput.setAttribute("tabindex", "0");
	hexOutput.addEventListener("keydown", handleKeyDown);

	// åˆæœŸåŒ–æ™‚ã«å‹•çš„è¡Œæ•°ã‚’è¨ˆç®—
	document.addEventListener("DOMContentLoaded", () => {
		// å°‘ã—é…å»¶ã•ã›ã¦è¦ç´ ã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’å¾…ã¤
		setTimeout(() => {
			updateChunkSize();
		}, 100);
	});

	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºæ™‚ã®å†è¨ˆç®—ï¼ˆthrottledï¼‰
	const throttledResize = throttle(() => {
		if (currentFile) {
			const oldChunkSize = CHUNK_SIZE;
			updateChunkSize();
			
			// ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚ºãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã¯å†æç”»
			if (CHUNK_SIZE !== oldChunkSize) {
				lastUpdateOffset = -1; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒªã‚»ãƒƒãƒˆ
				updateDisplay();
			}
		}
	}, 250); // ãƒªã‚µã‚¤ã‚ºã¯250msé–“éš”ã§åˆ¶é™

	window.addEventListener("resize", throttledResize as EventListener);

	// Offsetå€¤ã‚¸ãƒ£ãƒ³ãƒ—æ©Ÿèƒ½
	function handleOffsetClick(): void {
		if (!currentFile) return;

		const input = prompt(
			"Jump to offset (hexadecimal, e.g., 1000 or 0x1000):",
			"0x" + currentOffset.toString(16).toUpperCase(),
		);

		if (input === null) return; // ã‚­ãƒ£ãƒ³ã‚»ãƒ«

		let targetOffset: number;
		try {
			// 16é€²æ•°ã¨ã—ã¦è§£æï¼ˆ0xãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã®æœ‰ç„¡ã‚’å•ã‚ãªã„ï¼‰
			const cleanInput = input.trim().toLowerCase();
			if (cleanInput.startsWith("0x")) {
				targetOffset = parseInt(cleanInput, 16);
			} else {
				targetOffset = parseInt(cleanInput, 16);
			}

			if (isNaN(targetOffset) || targetOffset < 0) {
				alert("Invalid offset value. Please enter a valid hexadecimal number.");
				return;
			}

			// ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºå†…ã«åˆ¶é™
			const maxOffset = getMaxOffset();
			targetOffset = Math.min(targetOffset, maxOffset);

			// è¡Œå¢ƒç•Œã«æƒãˆã‚‹
			targetOffset = Math.floor(targetOffset / BYTES_PER_LINE) * BYTES_PER_LINE;

			currentOffset = targetOffset;
			lastUpdateOffset = -1; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒªã‚»ãƒƒãƒˆ
			updateDisplay();
		} catch (error) {
			alert("Invalid offset value. Please enter a valid hexadecimal number.");
		}
	}

	// Offsetæƒ…å ±ã‚’ã‚¯ãƒªãƒƒã‚¯å¯èƒ½ã«ã™ã‚‹
	offsetInfo.addEventListener("click", handleOffsetClick);

	// Canvasä¸Šã§ã®ã‚¯ãƒªãƒƒã‚¯ã‚¸ãƒ£ãƒ³ãƒ—æ©Ÿèƒ½
	function handleCanvasClick(event: MouseEvent): void {
		if (!currentFile) return;

		const rect = canvas.getBoundingClientRect();
		const x = event.clientX - rect.left;
		const y = event.clientY - rect.top;

		// Canvaså†…ã®åº§æ¨™ã‚’ãƒ”ã‚¯ã‚»ãƒ«åº§æ¨™ã«å¤‰æ›
		const canvasX = Math.floor(x);
		const canvasY = Math.floor(y);

		// Canvasæç”»é ˜åŸŸå†…ã‹ãƒã‚§ãƒƒã‚¯
		if (canvasX < 0 || canvasX >= canvas.width || canvasY < 0 || canvasY >= canvas.height) {
			return;
		}

		// ã‚¯ãƒªãƒƒã‚¯ä½ç½®ã®ãƒã‚¤ãƒˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
		const bytesPerCanvasLine = CANVAS_BYTES_PER_LINE;
		const byteIndex = canvasY * bytesPerCanvasLine + canvasX;

		// ç¾åœ¨ã®Canvasè¡¨ç¤ºã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è€ƒæ…®ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«å†…ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
		const fileByteOffset = currentOffset + byteIndex;

		// ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºå†…ã‹ãƒã‚§ãƒƒã‚¯
		if (fileByteOffset >= totalFileSize) {
			return;
		}

		// 16ãƒã‚¤ãƒˆå¢ƒç•Œã«ä¸¸ã‚ãŸã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
		const targetOffset = Math.floor(fileByteOffset / BYTES_PER_LINE) * BYTES_PER_LINE;

		// æœ€å¤§ã‚ªãƒ•ã‚»ãƒƒãƒˆå†…ã«åˆ¶é™
		const maxOffset = getMaxOffset();
		const clampedOffset = Math.min(targetOffset, maxOffset);

		// ã‚¸ãƒ£ãƒ³ãƒ—å®Ÿè¡Œ
		if (clampedOffset !== currentOffset) {
			currentOffset = clampedOffset;
			lastUpdateOffset = -1; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒªã‚»ãƒƒãƒˆ
			updateDisplay();
		}
	}

	// Canvasã«ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
	canvas.addEventListener("click", handleCanvasClick);

	// ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½
	function handleDragEnter(event: DragEvent): void {
		event.preventDefault();
		dragCounter++;
		if (dragCounter === 1) {
			dragOverlay.classList.remove("hidden");
		}
	}

	function handleDragOver(event: DragEvent): void {
		event.preventDefault();
		event.dataTransfer!.dropEffect = "copy";
	}

	function handleDragLeave(event: DragEvent): void {
		event.preventDefault();
		dragCounter--;
		if (dragCounter === 0) {
			dragOverlay.classList.add("hidden");
		}
	}

	function handleDrop(event: DragEvent): void {
		event.preventDefault();
		dragCounter = 0;
		dragOverlay.classList.add("hidden");

		const files = event.dataTransfer?.files;
		if (files && files.length > 0) {
			const file = files[0];
			// æ—¢å­˜ã®handleFileChangeé–¢æ•°ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’æµç”¨
			processDroppedFile(file);
		}
	}

	async function processDroppedFile(file: File): Promise<void> {
		currentFile = file;
		totalFileSize = file.size;
		currentOffset = 0;
		lastUpdateOffset = -1; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒªã‚»ãƒƒãƒˆ

		fileName.textContent = file.name;
		fileSize.textContent = formatFileSize(file.size);

		// è¡¨ç¤ºè¡Œæ•°ã‚’å‹•çš„ã«è¨ˆç®—ã—ã¦æ›´æ–°
		updateChunkSize();

		try {
			await updateDisplay();
		} catch (error) {
			console.error("Error reading file:", error);
			statusMessage.textContent = "Error loading file";
			statusMessage.classList.remove("loading");
		}
	}

	// ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’documentã«è¿½åŠ 
	document.addEventListener("dragenter", handleDragEnter);
	document.addEventListener("dragover", handleDragOver);
	document.addEventListener("dragleave", handleDragLeave);
	document.addEventListener("drop", handleDrop);

</script>

<style>
	.file-info {
		display: flex;
		gap: 2rem;
		margin-top: 1rem;
	}

	.file-detail {
		display: flex;
		gap: 0.5rem;
		align-items: center;
	}

	.file-label {
		font-weight: 500;
		color: var(--text-secondary);
		min-width: 3rem;
	}

	#file-name {
		font-weight: 500;
		color: var(--text-primary);
		font-family: var(--font-mono);
		font-size: 0.875rem;
	}

	#file-size {
		color: var(--text-accent);
		font-family: var(--font-mono);
		font-size: 0.875rem;
	}

	.viewer-grid {
		display: grid;
		grid-template-columns: 1fr 300px;
		gap: 1.5rem;
		margin-top: 1.5rem;
	}

	.hex-output-container {
		max-height: 800px;
		display: flex;
		flex-direction: column;
	}

	.hex-display-wrapper {
		flex: 1;
		display: flex;
		margin-top: 1rem;
		gap: 0; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚’éš™é–“ãªãé…ç½® */
	}

	.hex-output {
		flex: 1;
		font-family: var(--font-mono);
		font-size: 0.8rem;
		line-height: 1.4;
		color: var(--text-primary);
		white-space: pre;
		padding: 1rem;
		background: var(--bg-tertiary);
		border-radius: var(--radius-md);
		border: 1px solid var(--border-primary);
		max-height: 600px;
		overflow: hidden; /* å†…è”µã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç„¡åŠ¹åŒ– */
		border-top-right-radius: 0;
		border-bottom-right-radius: 0;
		border-right: none;
	}

	.custom-scrollbar {
		width: 12px;
		background: var(--bg-tertiary);
		border: 1px solid var(--border-primary);
		border-left: none;
		border-top-right-radius: var(--radius-md);
		border-bottom-right-radius: var(--radius-md);
		position: relative;
		max-height: 600px;
	}

	.custom-scrollbar.hidden {
		display: none;
	}

	.scrollbar-track {
		position: absolute;
		top: 2px;
		left: 2px;
		right: 2px;
		bottom: 2px;
		background: var(--bg-secondary);
		border-radius: 4px;
		cursor: pointer;
	}

	.scrollbar-thumb {
		position: absolute;
		left: 0;
		right: 0;
		background: var(--text-muted);
		border-radius: 4px;
		cursor: pointer;
		transition: background-color 0.2s ease;
		min-height: 20px;
		opacity: 0.8;
	}

	.scrollbar-thumb:hover {
		background: var(--text-secondary);
		opacity: 1;
	}

	.scrollbar-thumb.dragging {
		background: var(--accent-primary);
		opacity: 1;
	}

	.scroll-info {
		display: flex;
		justify-content: space-between;
		margin-top: 0.5rem;
		font-size: 0.75rem;
		color: var(--text-secondary);
		font-family: var(--font-mono);
	}

	#offset-info {
		cursor: pointer;
		padding: 0.25rem 0.5rem;
		border-radius: var(--radius-sm);
		transition: all 0.2s ease;
	}

	#offset-info:hover {
		background: var(--bg-card);
		color: var(--accent-primary);
		transform: translateY(-1px);
	}


	.canvas-container {
		display: flex;
		flex-direction: column;
		max-height: 800px;
	}

	.canvas-wrapper {
		flex: 1;
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 1rem;
		margin-top: 1rem;
	}

	#hex-canvas {
		border: 1px solid var(--border-primary);
		image-rendering: pixelated;
		background: var(--bg-tertiary);
		box-shadow: var(--shadow-md);
		transition: box-shadow 0.2s ease;
		cursor: pointer;
	}

	#hex-canvas:hover {
		box-shadow: var(--shadow-lg), 0 0 10px rgba(59, 130, 246, 0.3);
		border-color: var(--accent-primary);
	}

	.color-legend {
		display: grid;
		grid-template-columns: repeat(2, 1fr);
		gap: 0.5rem;
		width: 100%;
		max-width: 256px;
	}

	.legend-item {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		font-size: 0.75rem;
		color: var(--text-secondary);
	}

	.color-sample {
		width: 12px;
		height: 12px;
		border-radius: 2px;
		flex-shrink: 0;
	}

	.format-info {
		font-size: 0.75rem;
		color: var(--text-muted);
		font-family: var(--font-mono);
	}

	/* Status bar */
	.status-bar {
		margin-top: 1rem;
		padding: 0.5rem 1rem;
		background: var(--bg-tertiary);
		border: 1px solid var(--border-primary);
		border-radius: var(--radius-md);
		display: flex;
		align-items: center;
		min-height: 2rem;
	}

	#status-message {
		font-size: 0.875rem;
		color: var(--text-secondary);
		font-family: var(--font-mono);
	}

	#status-message.loading {
		color: var(--accent-primary);
		position: relative;
	}

	#status-message.loading::after {
		content: "";
		width: 12px;
		height: 12px;
		border: 2px solid var(--border-primary);
		border-top: 2px solid var(--accent-primary);
		border-radius: 50%;
		animation: spin 1s linear infinite;
		margin-left: 0.5rem;
		display: inline-block;
	}

	@keyframes spin {
		0% {
			transform: rotate(0deg);
		}
		100% {
			transform: rotate(360deg);
		}
	}

	/* Empty state */
	.hex-output:empty::before {
		content: "Select a file to view its hex dump...";
		color: var(--text-muted);
		font-style: italic;
		display: flex;
		align-items: center;
		justify-content: center;
		height: 100%;
	}

	/* Animation for canvas */
	@keyframes canvasLoad {
		0% {
			opacity: 0;
			transform: scale(0.9);
		}
		100% {
			opacity: 1;
			transform: scale(1);
		}
	}

	#hex-canvas.loaded {
		animation: canvasLoad 0.3s ease-out;
	}

	/* Hover effects */
	.glass-card:hover {
		transform: translateY(-2px);
	}

	.result-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 0;
		padding-bottom: 0;
	}

	.result-header h3 {
		margin: 0;
		font-size: 1.1rem;
	}

	/* File input enhancements */
	.file-input:hover .file-input-label {
		border-color: var(--accent-primary);
		background: var(--bg-card);
		color: var(--text-primary);
	}

	.file-input.has-file .file-input-label {
		border-color: var(--accent-success);
		background: var(--bg-card);
		color: var(--accent-success);
	}

	/* ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
	.drag-overlay {
		position: fixed;
		top: 0;
		left: 0;
		width: 100vw;
		height: 100vh;
		background: rgba(59, 130, 246, 0.1);
		backdrop-filter: blur(5px);
		z-index: 9999;
		display: flex;
		align-items: center;
		justify-content: center;
		pointer-events: none;
		transition: opacity 0.2s ease;
	}

	.drag-overlay.hidden {
		opacity: 0;
		pointer-events: none;
		display: none;
	}

	.drag-message {
		background: var(--bg-card);
		border: 2px dashed var(--accent-primary);
		border-radius: var(--radius-lg);
		padding: 3rem;
		text-align: center;
		box-shadow: var(--shadow-xl);
		transform: scale(0.9);
		animation: dragPulse 1.5s ease-in-out infinite;
	}

	.drag-icon {
		font-size: 4rem;
		margin-bottom: 1rem;
		opacity: 0.8;
	}

	.drag-text {
		font-size: 1.5rem;
		font-weight: 600;
		color: var(--accent-primary);
		margin: 0;
	}

	@keyframes dragPulse {
		0%, 100% {
			transform: scale(0.9);
			opacity: 0.8;
		}
		50% {
			transform: scale(1);
			opacity: 1;
		}
	}
</style>
