---
---

<div class="tool-container">
	<div class="tool-header">
		<h1>üìä Hex Dump Tool</h1>
		<p>Binary file analysis with hexdump display and visual representation</p>
	</div>
	
	<div class="glass-card tool-controls">
		<div class="file-input">
			<input type="file" id="file-input" accept="*/*" />
			<div class="file-input-label">
				<span>üìÅ Choose Binary File</span>
			</div>
		</div>
		<div class="file-info">
			<div class="file-detail">
				<span class="file-label">File:</span>
				<span id="file-name">No file selected</span>
			</div>
			<div class="file-detail">
				<span class="file-label">Size:</span>
				<span id="file-size">-</span>
			</div>
		</div>
	</div>
	
	<div class="viewer-grid">
		<div class="glass-card hex-output-container">
			<div class="result-header">
				<h3>Hex Dump Output</h3>
				<div class="format-info">16 bytes per line</div>
			</div>
			<div id="hex-output" class="hex-output"></div>
		</div>
		
		<div class="glass-card canvas-container">
			<div class="result-header">
				<h3>Visual Representation</h3>
				<div class="format-info">256 bytes per line</div>
			</div>
			<div class="canvas-wrapper">
				<canvas id="hex-canvas" width="256" height="400"></canvas>
				<div class="color-legend">
					<div class="legend-item">
						<div class="color-sample" style="background: #FFFFFF; border: 1px solid var(--border-primary);"></div>
						<span>0x00</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #00FFFF;"></div>
						<span>0x01-0x1F</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #FF0000;"></div>
						<span>0x20-0x7E</span>
					</div>
					<div class="legend-item">
						<div class="color-sample" style="background: #000000;"></div>
						<span>0x80-0xFF</span>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>

<script>
	const fileInput = document.getElementById('file-input') as HTMLInputElement;
	const fileName = document.getElementById('file-name') as HTMLSpanElement;
	const fileSize = document.getElementById('file-size') as HTMLSpanElement;
	const hexOutput = document.getElementById('hex-output') as HTMLDivElement;
	const canvas = document.getElementById('hex-canvas') as HTMLCanvasElement;
	const ctx = canvas.getContext('2d')!;

	let fileBuffer: ArrayBuffer | null = null;
	let scrollTop = 0;
	const BYTES_PER_LINE = 16;
	const CANVAS_BYTES_PER_LINE = 256;
	const LINES_TO_DISPLAY = 50;

	function formatFileSize(bytes: number): string {
		if (bytes === 0) return '0 Bytes';
		const k = 1024;
		const sizes = ['Bytes', 'KB', 'MB', 'GB'];
		const i = Math.floor(Math.log(bytes) / Math.log(k));
		return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
	}

	function byteToHex(byte: number): string {
		return byte.toString(16).padStart(2, '0').toUpperCase();
	}

	function byteToChar(byte: number): string {
		return (byte >= 0x20 && byte <= 0x7E) ? String.fromCharCode(byte) : '.';
	}

	function getByteColor(byte: number): string {
		if (byte === 0x00) return '#FFFFFF';
		if (byte >= 0x01 && byte <= 0x1F) return '#00FFFF';
		if (byte >= 0x20 && byte <= 0x7E) return '#FF0000';
		return '#000000';
	}

	function generateHexDump(buffer: ArrayBuffer, offset: number, lines: number): string {
		const bytes = new Uint8Array(buffer);
		const maxOffset = Math.min(offset + lines * BYTES_PER_LINE, bytes.length);
		let output = '';

		for (let i = offset; i < maxOffset; i += BYTES_PER_LINE) {
			const lineOffset = i.toString(16).padStart(8, '0').toUpperCase();
			let hexPart = '';
			let textPart = '';

			for (let j = 0; j < BYTES_PER_LINE; j++) {
				const byteIndex = i + j;
				if (byteIndex < bytes.length) {
					const byte = bytes[byteIndex];
					hexPart += byteToHex(byte) + ' ';
					textPart += byteToChar(byte);
				} else {
					hexPart += '   ';
					textPart += ' ';
				}
			}

			output += `${lineOffset}: ${hexPart} |${textPart}|\n`;
		}

		return output;
	}

	function drawCanvas(buffer: ArrayBuffer, offset: number): void {
		const bytes = new Uint8Array(buffer);
		const canvasHeight = canvas.height;
		const bytesPerCanvasLine = CANVAS_BYTES_PER_LINE;
		
		ctx.clearRect(0, 0, canvas.width, canvas.height);

		for (let y = 0; y < canvasHeight; y++) {
			for (let x = 0; x < bytesPerCanvasLine; x++) {
				const byteIndex = offset + y * bytesPerCanvasLine + x;
				
				if (byteIndex < bytes.length) {
					const byte = bytes[byteIndex];
					ctx.fillStyle = getByteColor(byte);
					ctx.fillRect(x, y, 1, 1);
				}
			}
		}
	}

	function updateDisplay(): void {
		if (!fileBuffer) return;

		const hexDump = generateHexDump(fileBuffer, scrollTop, LINES_TO_DISPLAY);
		hexOutput.textContent = hexDump;

		drawCanvas(fileBuffer, scrollTop);
	}

	function handleScroll(event: Event): void {
		const target = event.target as HTMLElement;
		const scrollPercent = target.scrollTop / (target.scrollHeight - target.clientHeight);
		
		if (fileBuffer) {
			const totalBytes = fileBuffer.byteLength;
			const maxOffset = Math.max(0, totalBytes - LINES_TO_DISPLAY * BYTES_PER_LINE);
			scrollTop = Math.floor(scrollPercent * maxOffset);
			scrollTop = Math.floor(scrollTop / BYTES_PER_LINE) * BYTES_PER_LINE;
			updateDisplay();
		}
	}

	async function handleFileChange(event: Event): Promise<void> {
		const target = event.target as HTMLInputElement;
		const file = target.files?.[0];
		
		if (!file) return;

		fileName.textContent = file.name;
		fileSize.textContent = formatFileSize(file.size);

		try {
			fileBuffer = await file.arrayBuffer();
			scrollTop = 0;
			updateDisplay();
		} catch (error) {
			console.error('Error reading file:', error);
			alert('Error reading file');
		}
	}

	fileInput.addEventListener('change', handleFileChange);
	
	const hexOutputContainer = document.querySelector('.hex-output-container') as HTMLElement;
	hexOutputContainer.addEventListener('scroll', handleScroll);
</script>

<style>
	.file-info {
		display: flex;
		gap: 2rem;
		margin-top: 1rem;
	}

	.file-detail {
		display: flex;
		gap: 0.5rem;
		align-items: center;
	}

	.file-label {
		font-weight: 500;
		color: var(--text-secondary);
		min-width: 3rem;
	}

	#file-name {
		font-weight: 500;
		color: var(--text-primary);
		font-family: var(--font-mono);
		font-size: 0.875rem;
	}

	#file-size {
		color: var(--text-accent);
		font-family: var(--font-mono);
		font-size: 0.875rem;
	}

	.viewer-grid {
		display: grid;
		grid-template-columns: 1fr 300px;
		gap: 1.5rem;
		margin-top: 1.5rem;
	}

	.hex-output-container {
		min-height: 600px;
		display: flex;
		flex-direction: column;
	}

	.hex-output {
		flex: 1;
		font-family: var(--font-mono);
		font-size: 0.8rem;
		line-height: 1.4;
		color: var(--text-primary);
		white-space: pre;
		overflow-y: auto;
		padding: 1rem;
		background: var(--bg-tertiary);
		border-radius: var(--radius-md);
		border: 1px solid var(--border-primary);
		margin-top: 1rem;
	}

	.canvas-container {
		display: flex;
		flex-direction: column;
		min-height: 600px;
	}

	.canvas-wrapper {
		flex: 1;
		display: flex;
		flex-direction: column;
		align-items: center;
		gap: 1rem;
		margin-top: 1rem;
	}

	#hex-canvas {
		border: 1px solid var(--border-primary);
		border-radius: var(--radius-sm);
		image-rendering: pixelated;
		background: var(--bg-tertiary);
		box-shadow: var(--shadow-md);
		transition: box-shadow 0.2s ease;
	}

	#hex-canvas:hover {
		box-shadow: var(--shadow-lg);
	}

	.color-legend {
		display: grid;
		grid-template-columns: repeat(2, 1fr);
		gap: 0.5rem;
		width: 100%;
		max-width: 256px;
	}

	.legend-item {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		font-size: 0.75rem;
		color: var(--text-secondary);
	}

	.color-sample {
		width: 12px;
		height: 12px;
		border-radius: 2px;
		flex-shrink: 0;
	}

	.format-info {
		font-size: 0.75rem;
		color: var(--text-muted);
		font-family: var(--font-mono);
	}


	/* Enhanced scrollbar for hex output */
	.hex-output::-webkit-scrollbar {
		width: 6px;
	}

	.hex-output::-webkit-scrollbar-track {
		background: var(--bg-secondary);
		border-radius: var(--radius-sm);
	}

	.hex-output::-webkit-scrollbar-thumb {
		background: var(--text-muted);
		border-radius: var(--radius-sm);
		transition: background 0.2s ease;
	}

	.hex-output::-webkit-scrollbar-thumb:hover {
		background: var(--text-secondary);
	}

	/* Loading state */
	.hex-output.loading {
		display: flex;
		align-items: center;
		justify-content: center;
		color: var(--text-muted);
		font-style: italic;
	}

	.hex-output.loading::before {
		content: 'Loading file...';
		display: flex;
		align-items: center;
		gap: 0.5rem;
	}

	.hex-output.loading::after {
		content: '';
		width: 16px;
		height: 16px;
		border: 2px solid var(--border-primary);
		border-top: 2px solid var(--accent-primary);
		border-radius: 50%;
		animation: spin 1s linear infinite;
	}

	/* Empty state */
	.hex-output:empty::before {
		content: 'Select a file to view its hex dump...';
		color: var(--text-muted);
		font-style: italic;
		display: flex;
		align-items: center;
		justify-content: center;
		height: 100%;
	}

	/* Animation for canvas */
	@keyframes canvasLoad {
		0% {
			opacity: 0;
			transform: scale(0.9);
		}
		100% {
			opacity: 1;
			transform: scale(1);
		}
	}

	#hex-canvas.loaded {
		animation: canvasLoad 0.3s ease-out;
	}

	/* Hover effects */
	.glass-card:hover {
		transform: translateY(-2px);
	}

	.result-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 0;
		padding-bottom: 0;
	}

	.result-header h3 {
		margin: 0;
		font-size: 1.1rem;
	}

	/* File input enhancements */
	.file-input:hover .file-input-label {
		border-color: var(--accent-primary);
		background: var(--bg-card);
		color: var(--text-primary);
	}

	.file-input.has-file .file-input-label {
		border-color: var(--accent-success);
		background: var(--bg-card);
		color: var(--accent-success);
	}
</style>